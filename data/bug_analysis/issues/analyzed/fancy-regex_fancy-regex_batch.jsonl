{"custom_id": "fancy-regex_fancy-regex_issue_3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"3\", \"title\": \"Re-enable coverage in build\", \"author\": \"robinst\", \"labels\": [], \"description\": \"We had to move coverage calculation to the nightly build (which is allowed to fail) here: https://github.com/fancy-regex/fancy-regex/pull/2\\r\\n\\r\\nOnce https://github.com/rust-lang/cargo/issues/6015 is resolved and released, we should be able to revert the above PR so that coverage is built on stable again.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Fixed: https://codecov.io/gh/fancy-regex/fancy-regex\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"6\", \"title\": \"Add support for backtracking limit\", \"author\": \"robinst\", \"labels\": [], \"description\": \"(Moved from previous location: https://github.com/google/fancy-regex/issues/44)\\r\\n\\r\\nGiven that it's possible to run into catastrophic backtracking, I think it would be nice if fancy-regex provided a way to set a limit on backtracking. If the VM reached that limit, it would return an error. Currently, the only way to stop it is to have a separate process and then kill the process.\\r\\n\\r\\nThere's some questions on how that would work:\\r\\n\\r\\n* Would it be a timeout (e.g. 1 second) or a number that would be incremented and checked when executing instructions\\r\\n* Would it be controllable via a cargo feature or part of the API when creating a regex (probably introduce a builder). (I'm not sure the feature would work, because that would mean in a crate with multiple dependencies that used fancy-regex, the feature would change the behavior for all those dependent crates.)\\r\\n\\r\\n@raphlinus's thoughts on this:\\r\\n\\r\\n> This is a good idea.\\r\\n>\\r\\n> I strongly prefer a deterministic approach rather than time. Among other things, running the cloud can introduce random and long delays, which would make tests flaky.\\r\\n>\\r\\n> Adding an option at regex creation time sounds good. Note that the API is already designed to fail when MAX_STACK is exceeded, with vm::State::run already returning a Result. So I think it can also be on by default, and won't be too disruptive.\\r\\n>\\r\\n> Thanks for agreeing to work on it, and let me know if you want more input.\\r\\nInterested to hear your thoughts on this @raphlinus, and happy to work on it!\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Released in 0.3.0\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"7\", \"title\": \"Update owners on crates.io and release new version\", \"author\": \"robinst\", \"labels\": [], \"description\": \"With the move to a new repo, we should do a release to update the metadata on https://crates.io/crates/fancy-regex\\r\\n\\r\\nThere were also many merged bugfixes. Maybe we should also start writing a CHANGELOG.md file.\\r\\n\\r\\n@raphlinus Do you mind adding me and the group as a whole as an owner to the crate?:\\r\\n\\r\\n```\\r\\ncargo owner --add robinst\\r\\ncargo owner --add github:fancy-regex:owners\\r\\n```\\r\\n\\r\\n(The first command gives me the permissions to extend owners as well, see the docs here: https://doc.rust-lang.org/cargo/reference/publishing.html#cargo-owner)\", \"comments\": [{\"author\": \"raphlinus\", \"body\": \"All sounds good, I added you as an owner.\\r\\n\"}, {\"author\": \"robinst\", \"body\": \"Hm, crates.io doesn't show me as an owner and neither does cargo:\\r\\n\\r\\n```\\r\\n$ cargo owner --list\\r\\n    Updating crates.io index\\r\\nraphlinus (Raph Levien)\\r\\n```\"}, {\"author\": \"raphlinus\", \"body\": \"I think it sends an invitation. Maybe there's a message in some inbox you need to accept?\"}, {\"author\": \"robinst\", \"body\": \"Oh, I found it on crates.io now!\\r\\n\\r\\nI didn't get an invite because I didn't have an email set on crates.io for some reason.\"}, {\"author\": \"Eh2406\", \"body\": \"I was told to move an issue here if it were still relevant, so I followed the link to find out what it was to decide if it should move, but the olde site had its issues deleted. So I can't tell. All I have to go on is the titles of the emails: witch both seam unresolved: \\\"add a expand to Captures\\\", and \\\"add a captures_iter to Regex\\\".\\r\\n\\r\\nAlso should the old [repo be marked archived](https://blog.github.com/2017-11-08-archiving-repositories/)?\"}, {\"author\": \"raphlinus\", \"body\": \"@Eh2406 Oh, making issues 404 seems pretty drastic, I mostly wanted to make it so new issues wouldn't be filed on the old repo. Archiving does sound like the best solution.\\r\\n\\r\\n@davelab6 ?\"}, {\"author\": \"cuviper\", \"body\": \"Hi - any update on releasing a new version?\"}, {\"author\": \"robinst\", \"body\": \"@cuviper: Not yet. I have time tomorrow, will take a look.\"}, {\"author\": \"robinst\", \"body\": \"Ok, here's a short todo list of things I'd like to do before the release:\\r\\n\\r\\n* [x] Change `find` to return a match object, see https://github.com/fancy-regex/fancy-regex/blob/master/src/lib.rs#L202-L204 (see #11)\\r\\n* [x] Add some howto style documentation on the module for `is_match` and `find` (see #11)\\r\\n* [x] Add a CHANGELOG.md (see https://keepachangelog.com/en/1.0.0/) (see #13)\"}, {\"author\": \"robinst\", \"body\": \"Found another thing: Now that we have `Match`, we should also change `Captures` to match regex's API:\\r\\n\\r\\n* Remove `pos` and `at` methods\\r\\n* Add `get` method that returns a `Option<Match>`\\r\\n* Remove `is_empty` (?)\"}, {\"author\": \"TheLostLambda\", \"body\": \"Hiya, how are things going on the new release front? I saw that the Match and Captures note here had a commit. Is there still work to do and can I help out?\\r\\n\"}, {\"author\": \"robinst\", \"body\": \"@TheLostLambda: Thanks for the offer :). I was working on running fancy-regex against the Oniguruma tests, which is now in a PR: #15.\\r\\n\\r\\nThe only thing in there which I'd like to fix before releasing is the panic, the rest can be done later.\"}, {\"author\": \"TheLostLambda\", \"body\": \"@robinst Sounds good! Do you mean that one of the tests causes a panic and you want to fix that? Which test is causing the issue?\"}, {\"author\": \"robinst\", \"body\": \"Yeah, some regexes cause a panic while matching, e.g. this one: https://github.com/fancy-regex/fancy-regex/pull/15/files#diff-2881bc063b93dfc8be4fece6d02954ddR243\"}, {\"author\": \"robinst\", \"body\": \"Done now! 0.2.0 is on crates.io: https://crates.io/crates/fancy-regex\\r\\n\\r\\nPosted on Reddit as well: https://www.reddit.com/r/rust/comments/djv01f/fancyregex_020_pure_rust_library_for_regexes_with/\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_34", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"34\", \"title\": \"Named capture groups\", \"author\": \"robinst\", \"labels\": [\"enhancement\", \"good first issue\"], \"description\": \"Named capture groups have been requested as a feature here: https://www.reddit.com/r/rust/comments/djv01f/z/f48r5ao\\r\\n\\r\\nShould not be too hard to implement:\\r\\n\\r\\nFirst, extend parser to parse named groups. Store it in a `HashMap<String, usize>`.\\r\\n\\r\\nThen add API to look up named groups using the name. Use the `HashMap` to look up the group index first.\\r\\n\\r\\nReferencing named groups in backrefs doesn't have to be implemented as part of this (but could be).\\r\\n\\r\\n#### Syntax\\r\\n\\r\\nOniguruma uses the syntax `(?<name>subexp)` whereas regex crate uses `(?P<name>subexp)`. We should probably support both.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"See https://github.com/fancy-regex/fancy-regex/pull/55\"}, {\"author\": \"robinst\", \"body\": \"@rxt1077 @johnw42 released in version 0.4.0 now: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#040---2020-09-27\\r\\n\\r\\nThank you both! üéâ \"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_37", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"37\", \"title\": \"Regex should match but doesn't because of delegation\", \"author\": \"robinst\", \"labels\": [\"bug\"], \"description\": \"The following test case:\\r\\n\\r\\n```rust\\r\\n    assert_match(r\\\"((?!x)(?:a|ab))c\\\", \\\"abc\\\");\\r\\n```\\r\\n\\r\\nCurrently doesn't pass. The reason for this is that `(?:a|ab)` is getting delegated to the regex crate at the moment, which means there's no backtracking. So this happens:\\r\\n\\r\\n1. Matches `a` from the delegated regex\\r\\n2. `c` doesn't match\\r\\n3. There is no backtracking to try `ab` because it's inside the delegated regex\\r\\n\\r\\nSo, it looks like for a group with hard parts, we can't delegate the end unless it's at the end of the pattern. I *think* we can delegate const-size parts, but need to check. But I wonder if there's other situations where we have the same problem. CC @raphlinus\", \"comments\": [{\"author\": \"intgr\", \"body\": \"Thank you! I was looking forward to this fix.\"}, {\"author\": \"robinst\", \"body\": \"@intgr: Cool. Out of interest, how did you hit this bug?\"}, {\"author\": \"intgr\", \"body\": \"I didn't actually hit the bug. I was impressed by the performance of Rust's regex engine and had a few thoughts where it could be applied. But it didn't support advanced features and the fact that fancy-regex could return incorrect results made me wary.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_48", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"48\", \"title\": \"One match being returned twice instead of two different matches\", \"author\": \"panther99\", \"labels\": [], \"description\": \"I'm trying to find the matches for the following regular expression (basically everything between `{#` and `}`):\\r\\n\\r\\n```\\r\\n(?<={#)(.*?)(?=})\\r\\n```\\r\\n\\r\\nHowever, instead of getting both matches for the example below, I get two matches with the content of the first match.\\r\\n\\r\\n```rs\\r\\nlet input = String::from(\\\"{#test1} {#test2}\\\");\\r\\nlet re = Regex::new(\\\"(?<={#)(.*?)(?=})\\\").unwrap();\\r\\n\\r\\nlet input_string_slice = &input.clone();\\r\\nlet result = re.captures(input_string_slice);\\r\\n\\r\\nlet captures = result.expect(\\\"Error during regex parsing\\\").expect(\\\"No match found\\\");\\r\\nlet first_match = captures.get(1).expect(\\\"No group\\\");\\r\\nlet second_match = captures.get(2).expect(\\\"No group\\\"); // panics\\r\\nprintln!(\\\"{} {}\\\", first_match.as_str(), second_match.as_str());\\r\\n```\\r\\n\\r\\n[Here](https://stackoverflow.com/questions/62487304/fancy-regex-not-returning-all-matches-in-the-input) is a question on StackOverflow where user Kitsu also posted the code which proves this. At first I thought I forgot to put global match so I'm only getting the first match, but by browsing the documentation I realized that's not the case.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"I'm a little confused, but maybe I'm just misunderstanding something :)\\r\\n\\r\\nYou've got one capture group in your regex pattern. Surely you need to run the regex VM multiple times, once starting at position 0, then again starting at the end of the previous match until you find no more matches... instead of trying to access a non-existent second capture group?\\r\\n\\r\\n```sh\\r\\ncargo run --example toy -- run '(?<={#)(.*?)(?=})' '{#test1} {#test2}' 0\\r\\n```\\r\\n\\r\\n> captures: 0:[2..7] \\\"test1\\\" 1:[2..7] \\\"test1\\\"\\r\\niterate Some(Match { text: \\\"{#test1} {#test2}\\\", start: 2, end: 7 })\\r\\niterate Some(Match { text: \\\"{#test1} {#test2}\\\", start: 2, end: 7 })\\r\\n\\r\\n\\r\\n```sh\\r\\ncargo run --example toy -- run '(?<={#)(.*?)(?=})' '{#test1} {#test2}' 7\\r\\n```\\r\\n> captures: 0:[11..16] \\\"test2\\\" 1:[11..16] \\\"test2\\\"\\r\\niterate Some(Match { text: \\\"{#test1} {#test2}\\\", start: 11, end: 16 })\\r\\niterate Some(Match { text: \\\"{#test1} {#test2}\\\", start: 11, end: 16 })\\r\\n\\r\\n\\r\\nEDIT: and to show a graph of the instructions:\\r\\n```sh\\r\\ncargo run --example toy -- graph '(?<={#)(.*?)(?=})' | dot -Tpng -o graph.png && xdg-open ./graph.png\\r\\n```\\r\\n\"}, {\"author\": \"panther99\", \"body\": \"> Surely you need to run the regex VM multiple times\\r\\n\\r\\nNot sure if I understood you here - I need to check for the matches multiple times remembering last positions of the previous matches? \\r\\n\\r\\nHonestly I don't have much experience using regular expression libraries but I would expect to get all the matches in one pass, without having to do it multiple times.\"}, {\"author\": \"robinst\", \"body\": \"Thanks @keith-hall, for helping out :). Yeah, Keith is right, you need to match multiple times to get all matches.\\r\\n\\r\\nWith the regex crate, you would use [captures_iter](https://docs.rs/regex/1.3.9/regex/struct.Regex.html#method.captures_iter) for that. fancy-regex doesn't have that API yet, so you currently need to use [captures_from_pos](https://docs.rs/fancy-regex/0.3.5/fancy_regex/struct.Regex.html#method.captures_from_pos) multiple times.\"}, {\"author\": \"panther99\", \"body\": \"I understand now. Thanks for the help.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_49", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"49\", \"title\": \"Add Regex::replace (and replacen, replaceall)\", \"author\": \"himat\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"I thought this crate would have a replace or replace_all like the rust regex crate does.\\r\\nIs there any way to do replace with this crate?\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Yeah it doesn't provide replace functionality yet. You can implement it yourself by repeatedly calling `captures_from_pos` and adding the pieces of the string before/after matches.\"}, {\"author\": \"robinst\", \"body\": \"With 0.5.0 you can now use `captures_iter`, which makes it a bit easier. But it would still be nice to have `replace`.\"}, {\"author\": \"intgr\", \"body\": \"I created PR #75 to add replace methods and solve this.\"}, {\"author\": \"robinst\", \"body\": \"Hey! Thanks, I saw them but haven't had a chance to review. Thanks for your patience.\"}, {\"author\": \"robinst\", \"body\": \"Released in 0.7.0, thanks @intgr: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#070---2021-07-12\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_50", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"50\", \"title\": \"UnknownFlag(\\\"(?<\\\")\", \"author\": \"fdncred\", \"labels\": [], \"description\": \"Can you please point me in the right direction with this `UnknownFlag` error?\\r\\n\\r\\nMy regex is `(?<color>\\u001b\\\\[1;34m)(?<word>[[:alnum:][:space:][:punct:]]*).*?(?<other><span|<br)?` and it's stored in a HashMap like this:\\r\\n```rust\\r\\n    hash.insert(\\r\\n        15,\\r\\n        (\\r\\n            // Cyan\\r\\n            r\\\"(?<color>\\u001b\\\\[36m)(?<word>[[:alnum:][:space:][:punct:]]*).*?(?<other><span|<br)?\\\",\\r\\n            format!(\\r\\n                r\\\"<span style='color:{};'>$word</span>\\\",\\r\\n                color_hm.get(\\\"cyan\\\").expect(\\\"Error getting cyan text color\\\"),\\r\\n            ),\\r\\n        ),\\r\\n    );\\r\\n```\\r\\nI'm looping through the HashMap like this and `Regex::new` is giving this unknownflag on all of regexes.\\r\\n```rust\\r\\n    for n in 0..hash_count {\\r\\n        let value = hash.get(&n).expect(\\\"error getting hash at index\\\");\\r\\n        println!(\\\"[{}] [{}]\\\", value.0, value.1);\\r\\n        let re = Regex::new(&value.0).expect(\\\"problem with color regex\\\");\\r\\n```\\r\\nI know I must be missing some fundamental item here but I just don't see it. Any help would be greatly appreciated.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"If I'm understanding correctly, the [PR to add named capture group support](https://github.com/fancy-regex/fancy-regex/pull/47) hasn't been merged yet, so that could be the problem. \"}, {\"author\": \"fdncred\", \"body\": \"oh ya, you're right. Duh! I feel so stupid. Wish that change would get in. :) Closing. Thanks @keith-hall !\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_52", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"52\", \"title\": \"cannot apply unary operator `!` to type `std::result::Result<bool, fancy_regex::error::Error>`\", \"author\": \"ctopher7\", \"labels\": [], \"description\": \"to reproduce\\r\\n```\\r\\nlet regex = FancyRegex::new(r#\\\"^(?=.{6,30})(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*()_+=/\\\\-|\\\\\\\\{}\\\\[\\\\]\\\\:\\\\;\\\\\\\"\\\\',.<>?`~]).*$\\\"#).unwrap();\\r\\n\\r\\nassert!(regex.is_match(\\\"asdsadsad\\\"));\\r\\n```\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_59", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"59\", \"title\": \"Add Regex::captures_iter\", \"author\": \"robinst\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"See https://docs.rs/regex/1.3.9/regex/struct.Regex.html#method.captures_iter\\r\\n\\r\\nCurrently, you will have to call `captures_from_pos` repeatedly to get this. Would be good to add this as API. Other things such as the replace API would also make use of it (#49).\", \"comments\": [{\"author\": \"zyansheep\", \"body\": \"This would be very cool : )\\r\\nI'm trying to read terminal input and get list of inputs split by spaces except ignoring spaces inside quotes. regex doesn't work so i'm using fancy-regex.\\r\\n\\r\\nI have to do this instead:\\r\\n```rust\\r\\nlet string = r#\\\"some raw \\\"input here\\\" that I put in\\\"#;\\r\\nlet mut input: Vec<&str> = Vec::new();\\r\\nlet mut current_pos = 0;\\r\\nloop {\\r\\n      let capture = split_regex.captures_from_pos(string, current_pos).map_or(None, |c|c);\\r\\n      if let Some(Some(cap)) = capture.map(|c|c.get(0)) { current_pos = cap.end(); input.push(cap.as_str()) } else { break }\\r\\n}\\r\\n```\"}, {\"author\": \"4ntoine\", \"body\": \"+1\\r\\nMy use [case](https://stackoverflow.com/questions/66113765/how-to-rewrite-regexp-without-positive-look-ahead). Any chance to have it working now?\"}, {\"author\": \"robinst\", \"body\": \"@4ntoine Released in version 0.5.0 now, give it a try.\"}, {\"author\": \"zyansheep\", \"body\": \"Thanks! Works perfectly! Extra Tip: Use `.flatten()` to deal with the `Result<Match>` that the `Matches` iterator returns\\r\\n```rust\\r\\nlet input: Vec<&str> = regex.find_iter(&line[..]).flatten().map(|m|m.as_str()).collect()\\r\\n```\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_60", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"60\", \"title\": \"Add escape function\", \"author\": \"florianpircher\", \"labels\": [\"enhancement\", \"help wanted\", \"good first issue\"], \"description\": \"The `regex` crates provides an [`escape(text: &str) -> String` function](https://docs.rs/regex/1.4.1/regex/fn.escape.html) which ‚Äúescapes all regular expression meta characters in text‚Äù. This is especially useful when the regex pattern contains a dynamic value such as user-input or a network-response.\\r\\n\\r\\nFor example, a search that includes the user-input `id_name` might use the pattern\\r\\n\\r\\n```rust\\r\\nformat!(\\\"^(?:id|ref)={};\\\", id_name)\\r\\n```\\r\\n\\r\\nwhere `id_name` could include characters like `$`, `+`, or `?`. These characters would get interpreted as special regex sequences instead of plain text. Escaping the dynamic value would prevent this:\\r\\n\\r\\n```rust\\r\\nformat!(\\\"^(?:id|ref)={};\\\", fancy_regex::escape(id_name))\\r\\n```\\r\\n\\r\\nCurrently I use the `fancy_regex` crate for matching and the `regex` crate for quoting, but this is error-prone, since `fancy_regex` adds a number of [regex-pattern syntax-extensions](https://docs.rs/fancy-regex/0.4.0/fancy_regex/index.html#syntax) which are not handled by `regex::escape`.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Yeah makes sense to have. @johnw42 recently worked on expansion APIs (a little bit related), maybe this is something they would be interested in adding.\\r\\n\\r\\n> Currently I use the fancy_regex crate for matching and the regex crate for quoting, but this is error-prone, since fancy_regex adds a number of regex-pattern syntax-extensions which are not handled by regex::escape.\\r\\n\\r\\nWhich syntax causes problems in this? I'm asking because I'd expect regex crate's quoting to take care of them already, e.g. quoting all `\\\\` and `(`.\"}, {\"author\": \"florianpircher\", \"body\": \"> Which syntax causes problems in this? I'm asking because I'd expect regex crate's quoting to take care of them already, e.g. quoting all `\\\\` and `(`.\\r\\n\\r\\nThe existing `regex::escape` function handles in my testing all of the current fancy extensions:\\r\\n\\r\\n```rust\\r\\nlet s = r#\\\"\\\\h \\\\H \\\\e \\\\1 \\\\2 (?<name1>exp) \\\\k<name1> (?P<name2>exp) (?P=name2) (?=exp) (?!exp) (?<=exp) (?<!exp) (?>exp)\\\"#;\\r\\nlet e = regex::escape(s);\\r\\nlet re = fancy_regex::Regex::new(&e).unwrap();\\r\\nassert_eq!(s, re.find(s).unwrap().unwrap().as_str());\\r\\n```\\r\\n\\r\\nThe escaped value `e` looks like this:\\r\\n\\r\\n```\\r\\n\\\\\\\\h \\\\\\\\H \\\\\\\\e \\\\\\\\1 \\\\\\\\2 \\\\(\\\\?<name1>exp\\\\) \\\\\\\\k<name1> \\\\(\\\\?P<name2>exp\\\\) \\\\(\\\\?P=name2\\\\) \\\\(\\\\?=exp\\\\) \\\\(\\\\?!exp\\\\) \\\\(\\\\?<=exp\\\\) \\\\(\\\\?<!exp\\\\) \\\\(\\\\?>exp\\\\)\\r\\n```\\r\\n\\r\\nWhile this does work, it may not with future extensions to the `fancy-regex` crate (or to the `regex` crate). Using the escape function of one crate for another feels like something bound to break.\\r\\n\\r\\nMaybe `fancy-regex` can provide a proxy `fancy_regex::escape` function which forwards the result from `regex::escape` as long as the escaped output stays compatible. If any of the two crates adds incompatible syntax-extensions the implementation of `fancy_regex::escape` can be changed to accommodate that.\"}, {\"author\": \"johnw42\", \"body\": \"It's a bit unfortunate that the function I added for expansion templates is called `quote` rather than `escape`, but I don't know if it would be worth trying to change the name at this point.\\r\\n\\r\\nThe set of metacharacters is effectively part of the API of `regex` and `fancy-regex`, because changing it would change the meaning of existing expressions. Depending on `regex::escape` is therefore safe from a forward compatibility perspective.\\r\\nIt does feel messy, though, so IMHO it would be nice to make `fancy_regex::escape` work as well. Adding an `escape` function that either forwards to `regex::escape` or calls the private `push_quoted` function would be pretty trivial. I coded a version that returns `Cow<str>` like `Expander::quote` does; I'll put up a PR if anyone is interested.\"}, {\"author\": \"florianpircher\", \"body\": \"> It's a bit unfortunate that the function I added for expansion templates is called `quote` rather than `escape`, but I don't know if it would be worth trying to change the name at this point.\\r\\n\\r\\nIf you want to change the name, you could still keep the old `quote` function around and hide it from the docs. This is what the `regex` crates does with [`captures_read_at` and `read_captures_at`](https://docs.rs/regex/1.4.1/src/regex/re_unicode.rs.html#677-707). I don‚Äôt feel strongly about this, keeping the `quote` name is OK, too.\\r\\n\\r\\n> Adding an escape function that either forwards to regex::escape or calls the private push_quoted function would be pretty trivial. I coded a version that returns Cow<str> like Expander::quote does; I'll put up a PR if anyone is interested.\\r\\n\\r\\nSounds great, thank you!\"}, {\"author\": \"robinst\", \"body\": \"> If you want to change the name, you could still keep the old quote function around and hide it from the docs. This is what the regex crates does with captures_read_at and read_captures_at. I don‚Äôt feel strongly about this, keeping the quote name is OK, too.\\r\\n\\r\\nYeah good idea. I don't mind the name `quote` tbh, so I don't feel strongly about this. I don't think it's an often-used function either (the one on expander).\\r\\n\\r\\n> I'll put up a PR if anyone is interested.\\r\\n\\r\\nYes please!\"}, {\"author\": \"johnw42\", \"body\": \"Here's the PR: https://github.com/fancy-regex/fancy-regex/pull/61\"}, {\"author\": \"robinst\", \"body\": \"Released in version 0.4.1 üéâ \"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"66\", \"title\": \"Q: `case_insensitive` unsupported?\", \"author\": \"4ntoine\", \"labels\": [\"help wanted\", \"good first issue\"], \"description\": \"Hi, any chance to have `case_insensitive` similar to what is supported in \\\"regex\\\" crate?\\r\\n```\\r\\nlet new_regex = fancy_regex::RegexBuilder::new(&unescaped_source)\\r\\n       // .case_insensitive(!self.match_case.clone()) //unsupported by fancy::regex\\r\\n       .build()\\r\\n       .unwrap();\\r\\n```\", \"comments\": [{\"author\": \"dekellum\", \"body\": \"Is prefixing the regex with \\\"(?i)\\\" a sufficient workaround? \"}, {\"author\": \"4ntoine\", \"body\": \"@dekellum Thanks, i will try it - just wondered what's the point of having different API (compared to \\\"regex::Regex\\\").\"}, {\"author\": \"robinst\", \"body\": \"Hey, yeah `(?i)` at the start should have the exact same result. It would be nice to add that to the API, in general we want to be as close as possible to regex's API. It's just a matter of doing the work :). I've added a help-wanted label to this.\"}, {\"author\": \"4ntoine\", \"body\": \"I've found one related issue: `fancy_regex::Regex::new(\\\"??\\\")` is invalid, but `fancy_regex::Regex::new(\\\"(?!)??\\\")` is perfectly fine. Seems to be a validation bug.. Can you confirm?\\r\\n\\r\\n```\\r\\n    #[test]\\r\\n    fn test_case() {\\r\\n        let regex = regex::RegexBuilder::new(\\\"??\\\")\\r\\n            .case_insensitive(true)\\r\\n            .build();\\r\\n        assert!(regex.is_err());\\r\\n\\r\\n        let reg = fancy_regex::Regex::new(\\\"(?!)??\\\");\\r\\n        assert!(reg.is_ok()) // is expected to be err too to be consistent with regex::Regex\\r\\n    }\\r\\n```\\r\\nPS. \\\"0.4.1\\\" version used\"}, {\"author\": \"robinst\", \"body\": \"Moved to https://github.com/fancy-regex/fancy-regex/issues/68\\r\\n\\r\\nNote that the regex crate is expected to fail for `(?!)` because it doesn't support look-ahead. But nevertheless, it's a bug in fancy-regex, look-ahead/behind with repeat operators should not be allowed.\"}, {\"author\": \"4ntoine\", \"body\": \"I believe this ticket can be closed (and new one \\\"add API\\\" to add options be created if you decide it worth it).\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_68", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"68\", \"title\": \"Look-ahead/behind with repeat operator should not compile\", \"author\": \"robinst\", \"labels\": [], \"description\": \"From https://github.com/fancy-regex/fancy-regex/issues/66#issuecomment-779820378\\r\\n\\r\\nThe following types of regexes should not compile (but they currently do):\\r\\n\\r\\n```\\r\\n(?=a)*\\r\\n(?!)?\\r\\n(?=a){1,2}\\r\\n(?<=a)*\\r\\n(?<!a)*\\r\\n```\\r\\n\\r\\nNote that Oniguruma fails with this error: `target of repeat operator is invalid`\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Thanks for the fix, released in 0.7.1 now: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#071---2021-07-29\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_70", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"70\", \"title\": \"(|a)* matches more text than (|a)+ does\", \"author\": \"robinst\", \"labels\": [\"help wanted\"], \"description\": \"See https://github.com/rust-lang/regex/issues/779\\r\\n\\r\\nWe might have the same problem in our VM. Need to check what our behavior is (for hard regexes) and adjust it to match the new logic of regex crate, go regex, RE2 and co.\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_71", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"71\", \"title\": \"doesn't impl `clone` and `FromStr`\", \"author\": \"steveej\", \"labels\": [], \"description\": \"These two trait impls would be convenient for building CLI applications that use structs for passing on arguments to subcommands.\\r\\n\\r\\nWithout these I'm using the following workarounds.\\r\\n\\r\\nCustom parsing function with `StructOpt`. This assumes that `,` isn't used in the pattern itself, which of course is arbitrary and doesn't work in the general case.\\r\\n```rust\\r\\n    #[derive(StructOpt, Debug)]\\r\\n    pub(crate) struct Check {\\r\\n        #[structopt(long, default_value = \\\"\\\", parse(try_from_str = parse_regexmatch))]\\r\\n        pub(crate) packages_filters: fancy_regex::Regex,\\r\\n    }\\r\\n\\r\\n    fn parse_regexmatch(input: &str) -> Fallible<fancy_regex::Regex> {\\r\\n        let set = fancy_regex::Regex::new(\\r\\n            &input\\r\\n                .split(\\\",\\\")\\r\\n                .filter(|s| !s.is_empty())\\r\\n                .collect::<String>(),\\r\\n        )?;\\r\\n        Ok(set)\\r\\n    }\\r\\n```\\r\\n\\r\\nUsing `Regex::new` with `Regex::as_str()` as input. Being able to just call `Regex::clone` would be nice.\\r\\n```rust\\r\\n...\\r\\n                packages_filters: fancy_regex::Regex::new(self.packages_filters.as_str())\\r\\n                    .expect(\\\"regex is valid\\\"),\\r\\n...\\r\\n```\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hey! I just released 0.6.0 which should fix your issue: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#060---2021-05-17\\r\\n\\r\\nLet me know if it doesn't.\"}, {\"author\": \"steveej\", \"body\": \"Works great, thank you @robinst!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_72", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"72\", \"title\": \"Implement Display, Index for feature parity with regex\", \"author\": \"duckontheweb\", \"labels\": [], \"description\": \"While substituting this crate for `regex` in Stranger6667/jsonschema-rs#220 it came up that there are a couple traits that are implemented on `regex` and not here. These seems like pretty low-hanging fruit and would make it a bit easier to swap this in place of `regex`. These are the ones that I saw, but there may be others:\\r\\n\\r\\n* [`impl Display for Regex`](https://docs.rs/regex/1.5.4/regex/struct.Regex.html#impl-Display)\\r\\n* [`impl Index for Captures`](https://docs.rs/regex/1.5.4/regex/struct.Captures.html#impl-Index%3C%26%27i%20str%3E)\\r\\n\\r\\nI can put in a PR for these 2. I'll take a look at `Clone` and `FromStr` (from #71) as well to see what the level of effort would be there.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Released in 0.6.0: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#060---2021-05-17\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_74", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"74\", \"title\": \"Support look-behind assertions without constant size\", \"author\": \"intgr\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"I've been playing around with Wikipedia's RegExTypoFix project: https://en.wikipedia.org/wiki/Wikipedia:AutoWikiBrowser/Typos\\r\\n\\r\\nWhile most of the rules compile with fancy-regex, there are a few hundred that fail with error \\\"Look-behind assertion without constant size\\\", you can try it out at https://github.com/intgr/topy-rs\\r\\n\\r\\nNot sure how difficult the implementation would be.\\r\\n\", \"comments\": [{\"author\": \"intgr\", \"body\": \"A few example rules that fail:\\r\\n\\r\\n* Lookbehind error: rule 'Solely_' regex `\\\\b(?<![A-Z][a-z]{0,99}\\\\s{1,9})soley\\\\b`\\r\\n* Lookbehind error: rule 'Ousted' regex `\\\\b([oO])uts(ed|ing(?<!could\\\\s+outsing))\\\\b`\\r\\n* Lookbehind error: rule 'Dominican' regex `\\\\b[dD]omini?ci?an(s)?\\\\b(?<!Dominicans?)`\\r\\n* Lookbehind error: rule 'Idea' regex `\\\\b([iI])dae(s)?\\\\b(?<!\\\\b\\\\p{Lu}\\\\.\\\\s+idae)(?!'')`\\r\\n* Lookbehind error: rule 'Rebeli√≥n (1)' regex `(?<=\\\\b[lL]a\\\\s{1,9})\\\\b([rR])ebelion\\\\b`\\r\\n* Lookbehind error: rule '-acity' regex `(?=ac)(?<=\\\\b(?:[A-Z][a-z]*|[a-z]+))act?iy\\\\b`\\r\\n* Lookbehind error: rule '-fully' regex `(?=fuly)(?<=\\\\b(?:[A-Z][a-z]*|[a-z]+))fuly\\\\b`\\r\\n* Lookbehind error: rule '-ively' regex `(?=ivly)(?<=\\\\b(?:[A-Z][a-z]*|[a-z]+))ivly\\\\b`\\r\\n* Lookbehind error: rule 'Protect' regex `\\\\b([pP])retect([a-z]*)\\\\b(?<!tect(?:al|o|um))`\\r\\n* Lookbehind error: rule 'GPU' regex `\\\\b(?<=\\\\s)(?<!\\\\|\\\\s{0,9})([gG]pu)\\\\b(?![^\\\\s\\\\.]*\\\\.\\\\w)`\\r\\n\"}, {\"author\": \"robinst\", \"body\": \"Hey! Hm that's an interesting use case :).\\r\\n\\r\\nSo the current implementation of how to match look-behinds is to go back the exact number of characters in the string and then match the expression in the look-behind from there. For that to work, the expression must be a constant size (so not contain `?`, `*`, `+` or even `{n,m}`. Note e.g. [oniguruma](https://github.com/kkos/oniguruma) has the same limitation.\\r\\n\\r\\nThere is a good explanation of what various engines support here: https://www.regular-expressions.info/lookaround.html#limitbehind\\r\\n\\r\\nAnd the Wikipedia page also says that depending on which tool you use some rules might be skipped: https://en.wikipedia.org/wiki/Wikipedia:AutoWikiBrowser/Typos#Usage\\r\\n\\r\\nThe most generic implementation that would allow all kinds of expressions is to actually match the look-behind backwards (in reverse). It's not planned to implement that at the moment.\"}, {\"author\": \"intgr\", \"body\": \"The new [`regex-automata`](https://docs.rs/regex-automata/latest/regex_automata/) crate exposes many lower-level internals of the regex crate. Related blog article: https://blog.burntsushi.net/regex-internals/\\r\\n\\r\\nIt seems they expose the reverse matching capability in some engines as well. Possibly this can be used to add support for simpler look-behind assertions without the constant length limitation?\\r\\n\"}, {\"author\": \"lmmx\", \"body\": \"Unbounded captureless lookbehind regexes for Rust are discussed here, and I think relevant to this thread https://systemf.epfl.ch/blog/rust-regex-lookbehinds/\\n\\n- Related https://github.com/rust-lang/regex/issues/1273\"}, {\"author\": \"keith-hall\", \"body\": \"Thanks for drawing attention to it, that is very interesting. Once/if it gets merged, we can consider making use of it. Meanwhile I have been looking at other ideas of how to implement non-const-size/unbounded lookbehinds in fancy-regex while still allowing fancy features and capture groups to be used. But the priority is on supporting subexpression calls and recursion at the moment, so I have put it on hold for now...\"}, {\"author\": \"keith-hall\", \"body\": \"I raised a [draft PR which adds support for variable length simple lookbehinds](https://github.com/fancy-regex/fancy-regex/pull/194) in case it is useful. (I/we can build upon it later to support fancy features if really needed.) Note that for some reason word boundary assertions currently get marked as hard despite the regex crate supporting them, so some of the patterns mentioned in an earlier comment on this issue (like `(?=fuly)(?<=\\\\b(?:[A-Z][a-z]*|[a-z]+))fuly\\\\b`) are still unsupported.\\nIf someone wants to remove that and benchmark it to prove matching/finding is faster without going through the VM, it would be most welcome:\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/lib.rs#L1770-L1777\\n\\nI marked it as a draft because it still needs a few things to be considered:\\n- do we want to put it behind a feature flag so we don't pull in a regex-automata feature if we don't need it?\\n- better handling of errors when compiling the DFA fails\\n- better cache handling\\n- benchmarks to show that const size lookbehinds are still more efficient? (specifically the variable-sized alt implementation compared to constructing the reverse DFA etc.)\\n\\nIf someone wants to address these (instead of waiting for me to get round to it), feel free\"}, {\"author\": \"keith-hall\", \"body\": \"I decided to sacrifice some sleep time to polish the PR. I implemented all the points in my comment above. (Except for the hard word boundary stuff, which logically should be in a separate PR anyway.)\"}, {\"author\": \"keith-hall\", \"body\": \"Keeping open to track the fancy feature support in variable size lookbehinds\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_76", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"76\", \"title\": \"Panic on not common input\", \"author\": \"Stranger6667\", \"labels\": [], \"description\": \"Hi! Thank you for this library!\\r\\n\\r\\nWhile fuzzing the [jsonschema](https://github.com/Stranger6667/jsonschema-rs/issues/253) crate, I found that `fancy-regex` panics on `\\\\\\\\u` (and a few more similar patterns like `\\\\\\\\U` and `\\\\\\\\x`), with:\\r\\n\\r\\n```\\r\\nthread 'main' panicked at 'index out of bounds: the len is 2 but the index is 2', /home/stranger6667/.cargo/registry/src/github.com-1ecc6299db9ec823/fancy-regex-0.6.0/src/parse.rs:394:17\\r\\n```\\r\\n\\r\\n**Code to reproduce**:\\r\\n\\r\\n```rust\\r\\nfn main() {\\r\\n    fancy_regex::Regex::new(\\\"\\\\\\\\u\\\");\\r\\n}\\r\\n```\\r\\n\\r\\nThough it is an incomplete escape sequence, it will be nice to return `Err` in such cases as in `regex`:\\r\\n\\r\\n```\\r\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\r\\nregex parse error:\\r\\n    \\\\u\\r\\n      ^\\r\\nerror: incomplete escape sequence, reached end of pattern prematurely\\r\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\r\\n```\\r\\n\\r\\nProbably, the solution will be to check the bounds before going to `bytes[ix]` inside `Parser::parse_hex`.\\r\\nLet me know what do you think, I'll be happy to submit a PR to fix this :)\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Oh nice, thanks for doing that :)! Yeah the fix sounds good, looking forward to the PR.\"}, {\"author\": \"Stranger6667\", \"body\": \"You're very welcome :) Here goes a PR - #78 \"}, {\"author\": \"robinst\", \"body\": \"Released in 0.7.1 now: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#071---2021-07-29\\r\\n\\r\\nLet me know if you find any other problems using fuzzing!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_77", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"77\", \"title\": \"InvalidClass error\", \"author\": \"ronlobo\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nThanks for putting this together.\\r\\n\\r\\nI tried the crate for password validation via regex.\\r\\nThe regex can be found [here](https://www.ocpsoft.org/tutorials/regular-expressions/password-regular-expression/) and looks like this:\\r\\n\\r\\n`^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[*.!@$%^&(){}[]:;<>,.?/~_+-=|\\\\]).{8,32}$`\\r\\n\\r\\nwhich, according to the article, can be broken down to:\\r\\n\\r\\n```\\r\\n^                                            Match the beginning of the string\\r\\n(?=.*[0-9])                                  Require that at least one digit appear anywhere in the string\\r\\n(?=.*[a-z])                                  Require that at least one lowercase letter appear anywhere in the string\\r\\n(?=.*[A-Z])                                  Require that at least one uppercase letter appear anywhere in the string\\r\\n(?=.*[*.!@$%^&(){}[]:;<>,.?/~_+-=|\\\\])        Require that at least one special character appear anywhere in the string\\r\\n.{8,32}                                      The password must be at least 8 characters long, but no more than 32\\r\\n$                                            Match the end of the string.\\r\\n```\\r\\n\\r\\nWhile testing it, I receive the error \\\"InvalidClass\\\", which appear to be possible in 3 different places.\\r\\n\\r\\nAre there any known limitations that wouldn't allow this regex?\\r\\nWould it make sense to add test cases for more convenient use cases?\\r\\n\\r\\nThanks.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"> Are there any known limitations that wouldn't allow this regex?\\r\\n\\r\\nI don't think its about limitations, just fancy-regex is parsing using Oniguruma syntax rules, and that pattern frankly seems a bit dodgy for any parser.\\r\\n\\r\\nSpecifically, the special characters part: `[*.!@$%^&(){}[]:;<>,.?/~_+-=|\\\\]` - the slash before the closing square bracket at the end should probably be escaped, as should the `[]` inside, along with the `-`, the `&` and the `^` as they can have special meaning in character classes.\\r\\n\\r\\nDon't trust random regular expression patterns you find on the internet - try it somewhere like regex101.com and it may show you/explain all the syntax errors :) \"}, {\"author\": \"ronlobo\", \"body\": \"Thanks @keith-hall, that actually did the trick.\\r\\nBy escaping the suggested characters, it is working as expected.\\r\\n\\r\\n`^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[*.!@$%\\\\^\\\\&(){}\\\\[\\\\]:;<>,.?\\\\/~_+\\\\-=|\\\\\\\\]).{8,32}$`\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_82", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"82\", \"title\": \"Support for BranchReset\", \"author\": \"lizelive\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"https://www.regular-expressions.info/branchreset.html\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hey! Sounds like something that should not be too hard to implement with the current architecture. It might mean that we can't delegate the expression inside `(?|...)` to the regex crate, but that's ok. If someone wants to try to implement this that would be cool.\\r\\n\\r\\nLooking at [Oniguruma's docs](https://github.com/kkos/oniguruma/blob/master/doc/RE), it looks like it doesn't implement this?\"}, {\"author\": \"keith-hall\", \"body\": \"Thinking out loud here - is there a possibility to implement this by delegating the whole expression inside `(?|...)` and then renumbering the capture groups afterwards - assuming there are no backreferences referring to those groups of course? It feels like it should have best performance.\\r\\n\\r\\nBut I guess as we'd need to maintain the code for when there *are* backreferences, it might not make sense to have 2 implementations? Plus it could also affect behavior of when the branch reset group is repeated... (haven't thought about this much yet.)\\r\\n\\r\\nLet's say that we don't delegate the inner expression then, how could we go about this? I think it should be possible to do the work at analyze/compile time and not need any changes in the VM. When we encounter the branch reset group, we could store the next capture group number, and then when visiting the Alt `|`, we reset the capture group number. After the end of the branch reset group, we set the next capture group number to the \\\"next capture group number at the start of the group\\\" + the highest count of capture groups which were in a branch. Does that sound reasonable or am I missing something? :)\"}, {\"author\": \"robinst\", \"body\": \"> Thinking out loud here - is there a possibility to implement this by delegating the whole expression inside (?|...) and then renumbering the capture groups afterwards - assuming there are no backreferences referring to those groups of course? It feels like it should have best performance.\\r\\n\\r\\nYeah that should work. Currently for a `Delegate`, we record `start_group` and `end_group` which we use to shift the group positions. We'd have to change that to a `HashMap<usize, usize>` where we map each group number from the resulting match to where we want to save it to.\\r\\n\\r\\n> But I guess as we'd need to maintain the code for when there are backreferences, it might not make sense to have 2 implementations?\\r\\n\\r\\nOn first reading I was confused why backreferences mattered, but you mean when there's a backref within a capturing group? In that case we already can't delegate the expression, right? Or can you make an example for what the problem is with backreferences?\\r\\n\\r\\n> Does that sound reasonable or am I missing something? :)\\r\\n\\r\\nYep, sounds reasonable.\\r\\n\\r\\nBut before we implement this, I want to take a step back though and consider if we actually *want* to add support for branch reset. So far, we've had the goal of staying pretty close to Oniguruma's functionality. Oniguruma [doesn't support branch reset](https://github.com/kkos/oniguruma/blob/master/doc/RE). PCRE and derivates do, but I'm not convinced it's worth it. The regex crate rejected it [here](https://github.com/rust-lang/regex/issues/740). Thoughts?\"}, {\"author\": \"keith-hall\", \"body\": \"> On first reading I was confused why backreferences mattered, but you mean when there's a backref within a capturing group? In that case we already can't delegate the expression, right? Or can you make an example for what the problem is with backreferences?\\r\\n\\r\\nI was thinking with a pattern like `(?'before'x)(?|abc|(?'left'd)(?'middle'e)(?'right'f)|g(h)\\\\2)(?'after'y)` - with a backref inside the branch reset group. It should match `xghhy`. But if we delegate the whole branch reset group, `\\\\2` would not refer to `(h)`. But maybe we can renumber those backreferences also?\\r\\n\\r\\nAbout whether we want to implement this, good question. My thinking was we *can* implement it without sacrificing any oniguruma compatibility, so I didn't see why we shouldn't. But if our goal is to be a safe Oniguruma \\\"clone\\\", then it would make sense to hold off until Oniguruma has this functionality. I didn't see any requests for such a feature on their issue tracker, so I'm not sure if that would ever happen.\\r\\n\"}, {\"author\": \"robinst\", \"body\": \"Ok so the `\\\\2` is inside the branch reset group, that means the whole alt wouldn't be delegated (because backrefs are hard). Which means we'd run them on the VM, which means by the time we look at `\\\\2`, we should have the right capture group stored already.\\r\\n\\r\\nYeah. @lizelive did you have a pressing need for this or was it mostly for convenience? I'm leaning towards not implementing it for now (can reopen if we decide otherwise).\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_84", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"84\", \"title\": \"Support for the `bytes` API?\", \"author\": \"Alphare\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"Hi,\\r\\n\\r\\nI'm looking into `fancy-regex` to maybe add it to Mercurial's `hgignore` system instead of `regex` to allow for non-linear regex as a fallback. Right now we completely disable the Rust fast-path if we come across an unsupported pattern, which is kind of a bummer.\\r\\n\\r\\nWe're using the `bytes` API from the `regex` crate and it looks like it's missing from `fancy-regex`. Is is something that can be added?\\r\\n\\r\\nThanks\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hey!\\r\\n\\r\\nI haven't looked into how the `bytes` API works in `regex` at all, but given that we either delegate to regex or use our own VM which already internally prefers working with bytes, it should be possible. The biggest hurdle would probably be creating and maintaining the parallel API. I think `regex` does it via macros but yeah.\\r\\n\\r\\nSo it's probably not a trivial change, and I don't have any plans to work at it at the moment. I'll label this \\\"help wanted\\\" and see if someone wants to pick it up.\\r\\n\\r\\nAs a compromise for your solution, would it be possible to delegate to fancy-regex just in case your input and patterns are well-formed UTF-8 (which is probably the vast majority of cases)?\"}, {\"author\": \"Alphare\", \"body\": \"Thanks for getting back to me!\\r\\n\\r\\nI understand this is a decent amount of work, I think falling back to `fancy-regex` if `regex` itself fails (so reversing the fallback) and only doing the UTF8 conversion in that case should be a decent workaround that wouldn't impact performance for the \\\"common case\\\".\\r\\n\\r\\nI'll keep you updated on that experiment once I get some time to try it out.\"}, {\"author\": \"Alphare\", \"body\": \"I just tried it (something unrelated took some time to install :sweat_smile:), and there are a couple of issues with the workaround, I'll document those so it's easier to follow:\\r\\n\\r\\n- Not being able to pass in bytes means a utf-8 conversion/check for every single call (can be hundreds of thousands or millions per invocation in large repositories)\\r\\n- Either changing the signature from `path -> bool` to `path -> Result<bool, UTF8Error>` or silently eating those errors when they happen\\r\\n- `fancy-regex` does not have a way of specifying (for example in `RegexBuilder`) to *not* try `regex` first, which slows us down because we've already tried it and it's doing the work twice\\r\\n- The performance seems to fall off of a cliff, but that's probably to do with the pattern themselves, which can most likely be turned into linear regex with some effort involved. Another idea I had was to identify patterns that aren't linear and split the linear parts from the backtracking ones to feed the latter to `fancy-regex` to have it build a smaller VM. But that's probably a lot of work.\\r\\n\\r\\nThanks for listening ;)\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_87", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"87\", \"title\": \"Support for Keep out \\\\K\", \"author\": \"Jafetlch\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"There is a method for this, without using lookbehind?\", \"comments\": [{\"author\": \"robinst\", \"body\": \"That's not currently supported, no. Here's a good reference for what it does and how it works: https://www.regular-expressions.info/keep.html\\r\\n\\r\\nI've added the labels for feature request and help wanted, and I'd be happy if someone wanted to take a stab at implementing this. It doesn't sound too hard to implement, and I can outline what would need to be done if anyone shows interest in picking this up.\"}, {\"author\": \"keith-hall\", \"body\": \"I'm interested to pick this up, though I can't commit much time to it so could be a while before I would be able to raise a PR.\\r\\nI guess it would just \\\"redefine\\\" where capture group 0 starts. I'm not sure how it would work if `\\\\K` is used inside a subexpression/repetition though - it may not be possible to do it when parsing the regular expression pattern, and have to be done at runtime? Just off the top of my head thoughts without refreshing my memory of the code first ;)\"}, {\"author\": \"robinst\", \"body\": \"Cool :)! Yep, I'm pretty sure it has to be done at runtime. I think it would involve roughly:\\r\\n\\r\\n1. Parsing `\\\\K` and creating an `Expr` for it and making sure the corresponding expression is marked as \\\"hard\\\" so that we won't try to delegate it to the regex crate. We can probably still delegate things before and after it to regex, but I haven't put much thought into that part yet.\\r\\n2. In the VM, whenever we encounter a `\\\\K` instruction, store the position as the match (group 0) start position (might have to keep track of the original as well so we can properly resume matching, not sure off the top of my head). That should just work for subexpressions and repetitions.\\r\\n\\r\\nThere's probably some special cases (e.g. can't be used within lookarounds) that we need to handle too, but yeah.\"}, {\"author\": \"robinst\", \"body\": \"@F34th3R Check out the 0.9.0 release which now includes support for `\\\\K`, thanks to @keith-hall!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_90", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"90\", \"title\": \"Some `toy` features broken in v0.9.0\", \"author\": \"keith-hall\", \"labels\": [], \"description\": \"Unfortunately it looks like I broke some features of the `toy` example when adding support for `\\\\K`.\\r\\n```sh\\r\\nfancy-regex on ÓÇ† main is üì¶ v0.9.0 via ü¶Ä v1.60.0 \\r\\n‚ú¶ ‚ùØ RUST_BACKTRACE=1 cargo run --example toy trace '\\\\d*' '1122 33'\\r\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.03s\\r\\n     Running `target/debug/examples/toy trace '\\\\d*' '1122 33'`\\r\\npos\\tinstruction\\r\\n0\\t0 Delegate { inner: ^\\\\d*, inner1: None, start_group: 0, end_group: 0 }\\r\\n4\\t1 End\\r\\nsaves: []\\r\\nthread 'main' panicked at 'index out of bounds: the len is 0 but the index is 1', src/vm.rs:305:9\\r\\nstack backtrace:\\r\\n   0: rust_begin_unwind\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/std/src/panicking.rs:584:5\\r\\n   1: core::panicking::panic_fmt\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/core/src/panicking.rs:143:14\\r\\n   2: core::panicking::panic_bounds_check\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/core/src/panicking.rs:85:5\\r\\n   3: <usize as core::slice::index::SliceIndex<[T]>>::index\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/core/src/slice/index.rs:189:10\\r\\n   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/core/src/slice/index.rs:15:9\\r\\n   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/alloc/src/vec/mod.rs:2531:9\\r\\n   6: fancy_regex::vm::State::get\\r\\n             at ./src/vm.rs:305:9\\r\\n   7: fancy_regex::vm::run\\r\\n             at ./src/vm.rs:442:33\\r\\n   8: fancy_regex::vm::run_trace\\r\\n             at ./src/vm.rs:403:5\\r\\n   9: toy::main\\r\\n             at ./examples/toy.rs:76:21\\r\\n  10: core::ops::function::FnOnce::call_once\\r\\n             at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c/library/core/src/ops/function.rs:227:5\\r\\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\\r\\n```\\r\\n\\r\\nIt would be great to get some `toy` runs added to CI to help prevent breakages like these :)\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Solved by https://github.com/fancy-regex/fancy-regex/pull/91 üëç \"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_96", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"96\", \"title\": \"Add an option to support only subset of regex available to Python\", \"author\": \"stepancheg\", \"labels\": [\"enhancement\"], \"description\": \"Documentation says:\\r\\n\\r\\n```\\r\\n(?<name>exp) : match exp, creating capture group named name\\r\\n\\\\k<name> : match the exact string that the capture group named name matched\\r\\n(?P<name>exp) : same as (?<name>exp) for compatibility with Python, etc.\\r\\n(?P=name) : same as \\\\k<name> for compatibility with Python, etc.\\r\\n```\\r\\n\\r\\nCan we have an option to allow only the latter synyax?\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Hi, I'm curious about the motivation for this and wish to clarify a few things.\\r\\n\\r\\nWhat problems does supporting syntax unavailable in Python give? And where to draw the line - in terms of, would you want to only enable features that are supported in some version of Python? If so, which version? Or is it purely about the named capture group/backref syntax?\\r\\n\\r\\nWould a compile time feature flag meet your needs, or would you expect it to be part of the API?\"}, {\"author\": \"stepancheg\", \"body\": \"> What problems does supporting syntax unavailable in Python give\\r\\n\\r\\nWe require compatibility with Python re, because:\\r\\n* we expose regex to users (users can enter regular expressions, they are not hardcoded)\\r\\n* other implementations of the same interface may not implement these extensions\\r\\n* we may want to switch regex implementation later keeping user interface, and regex entered by users should continue to work\\r\\n\\r\\nHowever, we can do regex validation before passing it to regex library, so if this feature is not implemented, it won't be a deal breaker.\\r\\n\\r\\n> Would a compile time feature flag meet your needs, or would you expect it to be part of the API?\\r\\n\\r\\nNo, compile flag (cargo feature) is not enough, because some other crate in dependency graph may enable/disable the feature and it will affect everyone.\"}, {\"author\": \"robinst\", \"body\": \"> No, compile flag (cargo feature) is not enough, because some other crate in dependency graph may enable/disable the feature and it will affect everyone.\\r\\n\\r\\nYeah, good point. The Oniguruma allows enabling/disabling a lot of parsing options, the one for this particular syntax is [here](https://github.com/kkos/oniguruma/blob/08d36110c5670c815ad6d6f969e578049d209080/src/oniguruma.h#L517).\\r\\n\\r\\nWe could make parsing configurable. It would add a bit of complexity to the parser but that's about it.\\r\\n\\r\\nBut what I'm not sure about is if that would be the only difference between this engine and another one. There's lots of subtle differences between implementations, e.g. how Unicode is treated, multiline etc.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_98", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"98\", \"title\": \"Add support for multi_line builder option\", \"author\": \"tgross35\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"`regex` has support for `RegexBuilder::multi_line()` ([source here](https://docs.rs/regex/latest/regex/struct.RegexBuilder.html#method.multi_line)), would it be possible to add that here? \\r\\n\\r\\nI think the implementation can be done with a simple transformation if full PCRE is enabled - `^` to `(?<=^|\\\\r\\\\n|\\\\n|\\\\x0b|\\\\f|\\\\r|\\\\x85)` and `$` to `(?=$|\\\\r\\\\n|\\\\n|\\\\x0b|\\\\f|\\\\r|\\\\x85)`\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hey! You can already get that behavior by starting your regex with `(?m)`. A `multi_line` method would be convenient to match regex's API though. I've added a \\\"help wanted\\\" label to this issue if anyone wants to contribute that work.\"}, {\"author\": \"ash0080\", \"body\": \"Interesting,  ?m seems not work, it will stop before the first line break even if I only use  r\\\".*\\\"\\r\\n```\\r\\nlet text = \\\"hello\\\\nworld\\\";\\r\\nlet re = Regex::new(r\\\"(?m)(.*)\\\").unwrap();\\r\\nlet caps = re.captures(text).unwrap().unwrap();\\r\\ndbg!(&caps);\\r\\ndbg!(&caps.get(0).unwrap().as_str());\\r\\n```\"}, {\"author\": \"robinst\", \"body\": \"Ah, sounds like you want [dot_matches_new_line](https://docs.rs/regex/latest/regex/struct.RegexBuilder.html#method.dot_matches_new_line) which is `(?s)`:\\r\\n\\r\\n```\\r\\n$ cargo run --example toy run '(?s)(.*)' 'hello\\\\nworld'\\r\\ncaptures: 0:[0..12] \\\"hello\\\\nworld\\\" 1:[0..12] \\\"hello\\\\nworld\\\"\\r\\n```\"}, {\"author\": \"robinst\", \"body\": \"Fixed in 0.15.0: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#0150---2025-07-06\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_101", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"101\", \"title\": \"Bad(?) performance with a specific regex with backreferences\", \"author\": \"intelfx\", \"labels\": [\"optimization/performance\"], \"description\": \"Consider this regular expression:\\r\\n```\\r\\n(..)\\\\1\\\\1\\\\1$\\r\\n```\\r\\n\\r\\nThis regular expression should match 4 identical groups of 2 characters at the end of the input string (e. g. `123456789ABABABAB` should match).\\r\\n\\r\\nWhen using fancy-regex to match this regular expression against a 40-character string, a single iteration takes almost 6 ¬µs if using the normal `Regex.is_match()` interface whereas manually compiling and running an `Expr` (as it is done in benchmarks) takes ~300 ns.\\r\\n\\r\\nFor comparison, an equivalent RE using only `regex` syntax (`(00000000|...|FFFFFFFF)$`) takes ~170 ns to run against the same 40-character string.\\r\\n\\r\\nI understand that `Regex` wraps the input RE in a super-expression implementing the \\\"match anywhere\\\" semantics, which probably explains the 20x performance difference, but I'm wondering if this is expected (and optimizing further is a non-goal or a wishlist-level goal) or if this is unexpected/a bug.\\r\\n\\r\\n<details><summary>bench.rs</summary>\\r\\n<p>\\r\\n\\r\\n```\\r\\n#[macro_use]\\r\\nextern crate criterion;\\r\\nextern crate rand;\\r\\n\\r\\nuse criterion::Criterion;\\r\\nuse std::time::Duration;\\r\\n\\r\\nuse fancy_regex::internal::{analyze, compile, run_default};\\r\\nuse fancy_regex::Expr;\\r\\n\\r\\nuse rand::Rng;\\r\\n\\r\\nstruct Hexadecimal;\\r\\nimpl rand::distributions::Distribution<u8> for Hexadecimal {\\r\\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {\\r\\n        const RANGE: u32 = 16;\\r\\n        const GEN_ASCII_STR_CHARSET: &[u8] = b\\\"0123456789ABCDEF\\\";\\r\\n        // We can pick from 62 characters. This is so close to a power of 2, 64,\\r\\n        // that we can do better than `Uniform`. Use a simple bitshift and\\r\\n        // rejection sampling. We do not use a bitmask, because for small RNGs\\r\\n        // the most significant bits are usually of higher quality.\\r\\n        loop {\\r\\n            let var = rng.next_u32() >> (32 - 4);\\r\\n            if var < RANGE {\\r\\n                return GEN_ASCII_STR_CHARSET[var as usize];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfn check_normal_expr(c: &mut Criterion) {\\r\\n    let re_str = \\\"(00000000|01010101|02020202|03030303|04040404|05050505|06060606|07070707|08080808|09090909|0A0A0A0A|0B0B0B0B|0C0C0C0C|0D0D0D0D|0E0E0E0E|0F0F0F0F|10101010|11111111|12121212|13131313|14141414|15151515|16161616|17171717|18181818|19191919|1A1A1A1A|1B1B1B1B|1C1C1C1C|1D1D1D1D|1E1E1E1E|1F1F1F1F|20202020|21212121|22222222|23232323|24242424|25252525|26262626|27272727|28282828|29292929|2A2A2A2A|2B2B2B2B|2C2C2C2C|2D2D2D2D|2E2E2E2E|2F2F2F2F|30303030|31313131|32323232|33333333|34343434|35353535|36363636|37373737|38383838|39393939|3A3A3A3A|3B3B3B3B|3C3C3C3C|3D3D3D3D|3E3E3E3E|3F3F3F3F|40404040|41414141|42424242|43434343|44444444|45454545|46464646|47474747|48484848|49494949|4A4A4A4A|4B4B4B4B|4C4C4C4C|4D4D4D4D|4E4E4E4E|4F4F4F4F|50505050|51515151|52525252|53535353|54545454|55555555|56565656|57575757|58585858|59595959|5A5A5A5A|5B5B5B5B|5C5C5C5C|5D5D5D5D|5E5E5E5E|5F5F5F5F|60606060|61616161|62626262|63636363|64646464|65656565|66666666|67676767|68686868|69696969|6A6A6A6A|6B6B6B6B|6C6C6C6C|6D6D6D6D|6E6E6E6E|6F6F6F6F|70707070|71717171|72727272|73737373|74747474|75757575|76767676|77777777|78787878|79797979|7A7A7A7A|7B7B7B7B|7C7C7C7C|7D7D7D7D|7E7E7E7E|7F7F7F7F|80808080|81818181|82828282|83838383|84848484|85858585|86868686|87878787|88888888|89898989|8A8A8A8A|8B8B8B8B|8C8C8C8C|8D8D8D8D|8E8E8E8E|8F8F8F8F|90909090|91919191|92929292|93939393|94949494|95959595|96969696|97979797|98989898|99999999|9A9A9A9A|9B9B9B9B|9C9C9C9C|9D9D9D9D|9E9E9E9E|9F9F9F9F|A0A0A0A0|A1A1A1A1|A2A2A2A2|A3A3A3A3|A4A4A4A4|A5A5A5A5|A6A6A6A6|A7A7A7A7|A8A8A8A8|A9A9A9A9|AAAAAAAA|ABABABAB|ACACACAC|ADADADAD|AEAEAEAE|AFAFAFAF|B0B0B0B0|B1B1B1B1|B2B2B2B2|B3B3B3B3|B4B4B4B4|B5B5B5B5|B6B6B6B6|B7B7B7B7|B8B8B8B8|B9B9B9B9|BABABABA|BBBBBBBB|BCBCBCBC|BDBDBDBD|BEBEBEBE|BFBFBFBF|C0C0C0C0|C1C1C1C1|C2C2C2C2|C3C3C3C3|C4C4C4C4|C5C5C5C5|C6C6C6C6|C7C7C7C7|C8C8C8C8|C9C9C9C9|CACACACA|CBCBCBCB|CCCCCCCC|CDCDCDCD|CECECECE|CFCFCFCF|D0D0D0D0|D1D1D1D1|D2D2D2D2|D3D3D3D3|D4D4D4D4|D5D5D5D5|D6D6D6D6|D7D7D7D7|D8D8D8D8|D9D9D9D9|DADADADA|DBDBDBDB|DCDCDCDC|DDDDDDDD|DEDEDEDE|DFDFDFDF|E0E0E0E0|E1E1E1E1|E2E2E2E2|E3E3E3E3|E4E4E4E4|E5E5E5E5|E6E6E6E6|E7E7E7E7|E8E8E8E8|E9E9E9E9|EAEAEAEA|EBEBEBEB|ECECECEC|EDEDEDED|EEEEEEEE|EFEFEFEF|F0F0F0F0|F1F1F1F1|F2F2F2F2|F3F3F3F3|F4F4F4F4|F5F5F5F5|F6F6F6F6|F7F7F7F7|F8F8F8F8|F9F9F9F9|FAFAFAFA|FBFBFBFB|FCFCFCFC|FDFDFDFD|FEFEFEFE|FFFFFFFF)$\\\";\\r\\n    let tree = Expr::parse_tree(re_str).unwrap();\\r\\n    let a = analyze(&tree).unwrap();\\r\\n    let p = compile(&a).unwrap();\\r\\n    c.bench_function(\\\"check_normal_expr\\\", |b| {\\r\\n        b.iter(|| {\\r\\n            let rng = rand::thread_rng();\\r\\n            let string: String = rng.sample_iter(Hexadecimal).take(40).map(char::from).collect();\\r\\n            run_default(&p, &string, 0).unwrap()\\r\\n        });\\r\\n    });\\r\\n}\\r\\n\\r\\nfn check_normal_regex(c: &mut Criterion) {\\r\\n    let re_str = \\\"(00000000|01010101|02020202|03030303|04040404|05050505|06060606|07070707|08080808|09090909|0A0A0A0A|0B0B0B0B|0C0C0C0C|0D0D0D0D|0E0E0E0E|0F0F0F0F|10101010|11111111|12121212|13131313|14141414|15151515|16161616|17171717|18181818|19191919|1A1A1A1A|1B1B1B1B|1C1C1C1C|1D1D1D1D|1E1E1E1E|1F1F1F1F|20202020|21212121|22222222|23232323|24242424|25252525|26262626|27272727|28282828|29292929|2A2A2A2A|2B2B2B2B|2C2C2C2C|2D2D2D2D|2E2E2E2E|2F2F2F2F|30303030|31313131|32323232|33333333|34343434|35353535|36363636|37373737|38383838|39393939|3A3A3A3A|3B3B3B3B|3C3C3C3C|3D3D3D3D|3E3E3E3E|3F3F3F3F|40404040|41414141|42424242|43434343|44444444|45454545|46464646|47474747|48484848|49494949|4A4A4A4A|4B4B4B4B|4C4C4C4C|4D4D4D4D|4E4E4E4E|4F4F4F4F|50505050|51515151|52525252|53535353|54545454|55555555|56565656|57575757|58585858|59595959|5A5A5A5A|5B5B5B5B|5C5C5C5C|5D5D5D5D|5E5E5E5E|5F5F5F5F|60606060|61616161|62626262|63636363|64646464|65656565|66666666|67676767|68686868|69696969|6A6A6A6A|6B6B6B6B|6C6C6C6C|6D6D6D6D|6E6E6E6E|6F6F6F6F|70707070|71717171|72727272|73737373|74747474|75757575|76767676|77777777|78787878|79797979|7A7A7A7A|7B7B7B7B|7C7C7C7C|7D7D7D7D|7E7E7E7E|7F7F7F7F|80808080|81818181|82828282|83838383|84848484|85858585|86868686|87878787|88888888|89898989|8A8A8A8A|8B8B8B8B|8C8C8C8C|8D8D8D8D|8E8E8E8E|8F8F8F8F|90909090|91919191|92929292|93939393|94949494|95959595|96969696|97979797|98989898|99999999|9A9A9A9A|9B9B9B9B|9C9C9C9C|9D9D9D9D|9E9E9E9E|9F9F9F9F|A0A0A0A0|A1A1A1A1|A2A2A2A2|A3A3A3A3|A4A4A4A4|A5A5A5A5|A6A6A6A6|A7A7A7A7|A8A8A8A8|A9A9A9A9|AAAAAAAA|ABABABAB|ACACACAC|ADADADAD|AEAEAEAE|AFAFAFAF|B0B0B0B0|B1B1B1B1|B2B2B2B2|B3B3B3B3|B4B4B4B4|B5B5B5B5|B6B6B6B6|B7B7B7B7|B8B8B8B8|B9B9B9B9|BABABABA|BBBBBBBB|BCBCBCBC|BDBDBDBD|BEBEBEBE|BFBFBFBF|C0C0C0C0|C1C1C1C1|C2C2C2C2|C3C3C3C3|C4C4C4C4|C5C5C5C5|C6C6C6C6|C7C7C7C7|C8C8C8C8|C9C9C9C9|CACACACA|CBCBCBCB|CCCCCCCC|CDCDCDCD|CECECECE|CFCFCFCF|D0D0D0D0|D1D1D1D1|D2D2D2D2|D3D3D3D3|D4D4D4D4|D5D5D5D5|D6D6D6D6|D7D7D7D7|D8D8D8D8|D9D9D9D9|DADADADA|DBDBDBDB|DCDCDCDC|DDDDDDDD|DEDEDEDE|DFDFDFDF|E0E0E0E0|E1E1E1E1|E2E2E2E2|E3E3E3E3|E4E4E4E4|E5E5E5E5|E6E6E6E6|E7E7E7E7|E8E8E8E8|E9E9E9E9|EAEAEAEA|EBEBEBEB|ECECECEC|EDEDEDED|EEEEEEEE|EFEFEFEF|F0F0F0F0|F1F1F1F1|F2F2F2F2|F3F3F3F3|F4F4F4F4|F5F5F5F5|F6F6F6F6|F7F7F7F7|F8F8F8F8|F9F9F9F9|FAFAFAFA|FBFBFBFB|FCFCFCFC|FDFDFDFD|FEFEFEFE|FFFFFFFF)$\\\";\\r\\n    let regex = fancy_regex::Regex::new(re_str).unwrap();\\r\\n    c.bench_function(\\\"check_normal_regex\\\", |b| {\\r\\n        b.iter(|| {\\r\\n            let rng = rand::thread_rng();\\r\\n            let string: String = rng.sample_iter(Hexadecimal).take(40).map(char::from).collect();\\r\\n            regex.is_match(&string).unwrap()\\r\\n        });\\r\\n    });\\r\\n}\\r\\n\\r\\n// The following regex is a pathological case for backtracking\\r\\n// implementations, see README.md:\\r\\nfn check_backref_expr(c: &mut Criterion) {\\r\\n    let tree = Expr::parse_tree(\\\"((..)\\\\\\\\1\\\\\\\\1\\\\\\\\1$)\\\").unwrap();\\r\\n    let a = analyze(&tree).unwrap();\\r\\n    let p = compile(&a).unwrap();\\r\\n    c.bench_function(\\\"check_backref_expr\\\", |b| {\\r\\n        b.iter(|| {\\r\\n            let rng = rand::thread_rng();\\r\\n            let string: String = rng.sample_iter(Hexadecimal).take(40).map(char::from).collect();\\r\\n            run_default(&p, &string, 0).unwrap()\\r\\n        });\\r\\n    });\\r\\n}\\r\\n\\r\\nfn check_backref_regex(c: &mut Criterion) {\\r\\n    let regex = fancy_regex::Regex::new(\\\"(..)\\\\\\\\1\\\\\\\\1\\\\\\\\1$\\\").unwrap();\\r\\n    c.bench_function(\\\"check_backref_regex\\\", |b| {\\r\\n        b.iter(|| {\\r\\n            let rng = rand::thread_rng();\\r\\n            let string: String = rng.sample_iter(Hexadecimal).take(40).map(char::from).collect();\\r\\n            regex.is_match(&string).unwrap()\\r\\n        });\\r\\n    });\\r\\n}\\r\\n\\r\\ncriterion_group!(\\r\\n    name = checks;\\r\\n    config = Criterion::default().warm_up_time(Duration::from_secs(10));\\r\\n    targets =\\r\\n    check_normal_expr,\\r\\n    check_normal_regex,\\r\\n    check_backref_expr,\\r\\n    check_backref_regex\\r\\n);\\r\\n\\r\\ncriterion_main!(checks);\\r\\n```\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n<details><summary>`cargo bench` output</summary>\\r\\n<p>\\r\\n\\r\\n```\\r\\n     Running benches/bench.rs (target/release/deps/bench-8117c8c31bf52a35)\\r\\nWARNING: HTML report generation will become a non-default optional feature in Criterion.rs 0.4.0.\\r\\nThis feature is being moved to cargo-criterion (https://github.com/bheisler/cargo-criterion) and will be optional in a future version of Criterion.rs. To silence this warning, either switch to cargo-criterion or enable the 'html_reports' feature in your Cargo.toml.\\r\\n\\r\\nGnuplot not found, using plotters backend\\r\\ncheck_normal_expr       time:   [2.6787 us 2.7315 us 2.7891 us]\\r\\nFound 5 outliers among 100 measurements (5.00%)\\r\\n  4 (4.00%) high mild\\r\\n  1 (1.00%) high severe\\r\\n\\r\\ncheck_normal_regex      time:   [168.07 ns 169.70 ns 171.54 ns]\\r\\nFound 2 outliers among 100 measurements (2.00%)\\r\\n  2 (2.00%) high mild\\r\\n\\r\\ncheck_backref_expr      time:   [304.59 ns 306.39 ns 308.37 ns]\\r\\nFound 5 outliers among 100 measurements (5.00%)\\r\\n  5 (5.00%) high mild\\r\\n\\r\\ncheck_backref_regex     time:   [6.4816 us 6.8658 us 7.3006 us]\\r\\nFound 15 outliers among 100 measurements (15.00%)\\r\\n  4 (4.00%) high mild\\r\\n  11 (11.00%) high severe\\r\\n```\\r\\n</p>\\r\\n</details>\", \"comments\": [{\"author\": \"robinst\", \"body\": \"> When using fancy-regex to match this regular expression against a 40-character string, a single iteration takes almost 6 ¬µs if using the normal `Regex.is_match()` interface whereas manually compiling and running an `Expr` (as it is done in benchmarks) takes ~300 ns.\\r\\n\\r\\nFor the latter case (`check_backref_expr`), can you assert that the result is actually what you expect? I think the way it's written it would never actually match (e.g. against `123456789ABABABAB`).\\r\\n\\r\\nApart from that, the runtime sounds about right with the current state of optimizations. The reason it's slow is that the pattern has to be tried 32 times before it succeeds; starting at position 0, then 1, until it finally succeeds at position 32. The non-backref regex with the regex crate might be able to figure out that it's a constant length and so can only ever potentially match the last 8 characters, or run the search backwards.\\r\\n\\r\\nI wonder what other engines do, for example Oniguruma. It seems to be pretty fast with 364.14 ns here. I had a look through the code and I think it might have optimizations for a fixed size match anchored at the end, e.g. see:\\r\\n\\r\\nhttps://github.com/kkos/oniguruma/blob/master/src/regcomp.c#L7024-L7027\\r\\n\"}, {\"author\": \"keith-hall\", \"body\": \"I have an idea which I believe would solve these type of performance problems...\\n\\nSo, as mentioned before, currently fancy-regex doesn't do anything smart about seeking to the earliest position in the haystack where the regex could match, it just does a full search beginning from each position in the haystack.\\nBut given that we know that the regex crate handles this, what if, instead of emitting instructions for the VM to check each position in the haystack - or optimizing specific regular expressions in fancy-regex by explicitly setting the start position based on the anchors and const length of the possible matches - we would emit a new \\\"Seek\\\" instruction, which would essentially interpret the regex pattern in a way that the regex crate could find us our earliest possible (next) match.\\n\\nAny feature which technically requires backtracking could be replaced with it's \\\"base\\\" node. (Not sure of a better term here, sorry.) So a backreference would be replaced with the contents of the group being referenced (essentially it becomes like an inlined subroutine call). A subroutine the same, up to the recursion depth limit of 20 - see https://github.com/fancy-regex/fancy-regex/issues/162#issuecomment-2891028868 for examples of how `oniguruma-to-es` emulates recursive subexpressions.\\nFor example, this concrete pattern:\\n```regex\\n(..)\\\\1\\\\1\\\\1$\\n```\\ncould be seeked to using\\n```regex\\n(..)......$\\n```\\n(the capture groups can be removed because we don't need them for seeking, I just left it here to provide a bit more clarity)\\n\\nNow, as usual with optimizations, there may need to be some heuristics to decide if it is worth applying in specific cases. But in general, the first time the seek operation is performed, it should be able to seek to the same position i.e. position 0. But if it seeked successfully, and then the match failed, the next time it seeks, it needs to ignore the position it previously seeked to and start from the next position in the haystack (if there is any/enough haystack left).\\n\\nOf course, there are many patterns which can't be easily expressed fully as a seek operation, for example a pattern with lookarounds (except for positive trailing lookaheads as we already know from #171). But if the pattern includes a specific literal or an anchor, it would still benefit from this optimization if those parts are silently dropped while seeking. The alternative would be to have multiple inner regex patterns for Seek to use, and take the latest position which is matched from any of those patterns, or keep seeking until all those inner patterns agree on the start position. i.e. just a nonsense pattern to demonstrate the concept\\n```regex\\n\\\\d+(?=\\\\w).{3}foo\\n```\\ncould have two seekable inner expressions:\\n```regex\\n\\\\d+\\\\w\\n\\\\d+.{3}foo\\n```\\nif we really want to be smart, that first one could even become\\n```regex\\n\\\\d+\\\\w.{2}foo\\n```\\nbut I doubt in many concrete cases it would be so possible, and likely not worth the effort.\\n\\nIt would be really interesting to benchmark these ideas, to see if they would help in reality.\\n\\nSide note: trailing negative lookaheads could perhaps be replaced with their opposite, so that\\n```regex\\nabc(?!def)\\n```\\nwould become\\n```regex\\nabc(?:$|[^d]|d(?:[^e]|$)|de(?:[^f]|$))\\n```\\n\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_103", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"103\", \"title\": \"panic when evaluating a specific regex\", \"author\": \"vthib\", \"labels\": [\"bug\"], \"description\": \"Using the regex & text used in benches, but with the public `Regex::new` API instead of the private one, leads to a panic in the eval VM:\\r\\n\\r\\n```rust\\r\\nuse fancy_regex::Regex;\\r\\n\\r\\nfn main() {\\r\\n    let regex = Regex::new(\\\"^.*?(([ab]+)\\\\\\\\1b)\\\").unwrap();\\r\\n    eprintln!(\\\"match: {:?}\\\", regex.is_match(\\\"babab\\\"));\\r\\n}\\r\\n```\\r\\n\\r\\ngives this:\\r\\n\\r\\n```\\r\\nthread 'main' panicked at 'byte index 18446744073709551615 is out of bounds of `babab`', library/core/src/str/mod.rs:107:9\\r\\nstack backtrace:\\r\\n   0: rust_begin_unwind\\r\\n             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/std/src/panicking.rs:584:5\\r\\n   1: core::panicking::panic_fmt\\r\\n             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/panicking.rs:142:14\\r\\n   2: core::str::slice_error_fail_rt\\r\\n   3: core::ops::function::FnOnce::call_once\\r\\n             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/ops/function.rs:248:5\\r\\n   4: core::intrinsics::const_eval_select\\r\\n             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/intrinsics.rs:2696:5\\r\\n   5: core::str::slice_error_fail\\r\\n             at /rustc/a55dd71d5fb0ec5a6a3a9e8c27b2127ba491ce52/library/core/src/str/mod.rs:86:9\\r\\n   6: fancy_regex::vm::run\\r\\n   7: fancy_regex::Regex::is_match\\r\\n   8: bug::main\\r\\n```\\r\\n\\r\\nThis is both present on `0.10.0` and on current main (f594a9ba1f675fce87b1f24a26d95d448afacc75)\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Thanks for reporting. This is also reproducible as `cargo run --example toy run '^.*?(([ab]+)\\\\1b)' babab`. It seems like it is somehow caused by the `.*` being lazy.\"}, {\"author\": \"robinst\", \"body\": \"Thanks for reporting! See https://github.com/fancy-regex/fancy-regex/pull/107 for a fix.\"}, {\"author\": \"robinst\", \"body\": \"Fix released in version 0.11.0: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#0110---2023-01-12\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_104", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"104\", \"title\": \"split function missing\", \"author\": \"priyankat99\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"i wanted to split a string with regex and was wondering if theres a reason that that function is missing? its implemented in the rust-regex crate and also their regex implements pattern so the std::split is an option as well. \\r\\ni am interested in adding it but wondering if it was purposely left out for some reason? \", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"I believe it has only been left out because nobody has needed it yet and thus nobody has implemented it yet. There have been some issues reported in the past where people asked for `fancy-regex` to implement some APIs that `regex` has and to my knowledge they have never been rejected.\"}, {\"author\": \"juan-coralogix\", \"body\": \"It would be an awesome feature. \"}, {\"author\": \"fdncred\", \"body\": \"definitely needed\"}, {\"author\": \"wez\", \"body\": \"I'm also missing this function.  I whipped up the following to satisfy my need, thought I'd share here in case someone has the bandwidth to make a proper PR out of it.\\r\\nThe logic here is a interpretation of https://github.com/rust-lang/regex/blob/8856fe36ac7dc37989e6ffb26b5fc57189bae626/regex-automata/src/meta/regex.rs#L2180-L2219 but adapted to work on the public types available from this crate.\\r\\n\\r\\n```rust\\r\\n\\r\\nstruct Split<'r, 'h> {\\r\\n    finder: Matches<'r, 'h>,\\r\\n    last: usize,\\r\\n    haystack: &'h str,\\r\\n}\\r\\n\\r\\nimpl<'r, 'h> Split<'r, 'h> {\\r\\n    fn split(re: &'r Regex, haystack: &'h str) -> Self {\\r\\n        Self {\\r\\n            finder: re.find_iter(haystack),\\r\\n            last: 0,\\r\\n            haystack,\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nimpl<'r, 'h> Iterator for Split<'r, 'h> {\\r\\n    type Item = Result<&'h str, fancy_regex::Error>;\\r\\n\\r\\n    fn next(&mut self) -> Option<Result<&'h str, fancy_regex::Error>> {\\r\\n        match self.finder.next() {\\r\\n            None => {\\r\\n                let len = self.haystack.len();\\r\\n                if self.last > len {\\r\\n                    None\\r\\n                } else {\\r\\n                    let span = &self.haystack[self.last..len];\\r\\n                    self.last = len + 1; // Next call will return None\\r\\n                    Some(Ok(span))\\r\\n                }\\r\\n            }\\r\\n            Some(Ok(m)) => {\\r\\n                let span = &self.haystack[self.last..m.start()];\\r\\n                self.last = m.end();\\r\\n                Some(Ok(span))\\r\\n            }\\r\\n            Some(Err(e)) => Some(Err(e)),\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfn split_into_vec(re: &Regex, haystack: &str) -> Result<Vec<String>, fancy_regex::Error> {\\r\\n    let mut result = vec![];\\r\\n    for m in Split::split(re, haystack) {\\r\\n        let m = m?;\\r\\n        result.push(m.to_string());\\r\\n    }\\r\\n    Ok(result)\\r\\n}\\r\\n\\r\\n#[cfg(test)]\\r\\nmod test {\\r\\n    use super::*;\\r\\n\\r\\n    #[test]\\r\\n    fn fancy_split() {\\r\\n        let re = Regex::new(\\\"[ \\\\t]+\\\").unwrap();\\r\\n        let hay = \\\"a b \\\\t  c\\\\td    e\\\";\\r\\n        let fields = split_into_vec(&re, hay).unwrap();\\r\\n        assert_eq!(fields, vec![\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\"]);\\r\\n    }\\r\\n}\\r\\n\\r\\n```\"}, {\"author\": \"k94-ishi\", \"body\": \"@wez \\r\\nI was able to create a pull request using your code as a reference. Thank you! \"}, {\"author\": \"robinst\", \"body\": \"`split` and `splitn` have been released in 0.14.0, thanks @k94-ishi üéâ ! https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#0140---2024-10-24\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_105", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"105\", \"title\": \"Cannot specify backreferences > 9\", \"author\": \"Alpvax\", \"labels\": [], \"description\": \"Does not support the \\\\g{xx} syntax for specifying backreferences, so there is no way to specify a group higher than 9.\\r\\n\\r\\nFrom regex101.com, as per PCRE2 regex, which accepts 2-digit backreferences:\\r\\n```\\r\\n\\\\#\\r\\n\\r\\nUsually referred to as a `backreference`, this will match a repeat of the text matched and captured\\r\\nby the capture group # (number) specified.\\r\\nTo reduce ambiguity one may also use \\\\g#, or \\\\g{#} where `#` is a digit.\\r\\n```\\r\\n\\r\\nMy usecase is matching many (14) consecutive characters to check that none are the same, using the following regex:\\r\\n`/(.)(?!\\\\1)(.)(?!\\\\1|\\\\2)(.)(?!\\\\1|\\\\2|\\\\3)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\g{10})(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\g{10}|\\\\g{11})(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\g{10}|\\\\g{11}|\\\\g{12})(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\g{10}|\\\\g{11}|\\\\g{12}|\\\\g{13})(.)/`\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"We're mainly trying to be compatible with Oniguruma syntax, and the [docs there state that `\\\\k` is for re-matching text captured by a capture group](https://github.com/kkos/oniguruma/blob/master/doc/RE#L407) - `\\\\g` would re-execute the subexpression, which may have the same effect depending on what that expression is, but I just wanted to point out the distinction.\\r\\n\\r\\nHow does this help? Well, this seems to work in `fancy-regex`:\\r\\n`cargo run --example toy run '(.)(?!\\\\1)(.)(?!\\\\1|\\\\2)(.)(?!\\\\1|\\\\2|\\\\3)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\k<10>)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\k<10>|\\\\k<11>)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\k<10>|\\\\k<11>|\\\\k<12>)(.)(?!\\\\1|\\\\2|\\\\3|\\\\4|\\\\5|\\\\6|\\\\7|\\\\8|\\\\9|\\\\k<10>|\\\\k<11>|\\\\k<12>|\\\\k<13>)(.)' 'abcdefghijklmn'`\\r\\n\\r\\n> iterate Some(Match { text: \\\"abcdefghijklmn\\\", start: 0, end: 14 })\\r\\n\"}, {\"author\": \"Alpvax\", \"body\": \"Thanks for letting me know. I'm happy to call that resolved\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_106", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"106\", \"title\": \"fancy_regex::Error std Error support?\", \"author\": \"jgarvin\", \"labels\": [], \"description\": \"In my crate specific error enum I try to wrap fancy_regex errors:\\r\\n\\r\\n```\\r\\n#[derive(thiserror::Error, Debug)]\\r\\npub enum Error {\\r\\n    #[error(\\\"Regex error: {0}\\\")]\\r\\n    Regex(#[from] fancy_regex::Error),\\r\\n}\\r\\n```\\r\\n\\r\\nThis fails:\\r\\n\\r\\n```\\r\\nerror[E0599]: the method `as_dyn_error` exists for reference `&fancy_regex::Error`, but its trait bounds were not satisfied\\r\\n  --> src/lib.rs:62:13\\r\\n   |\\r\\n62 |     #[error(\\\"Regex error: {0}\\\")]\\r\\n   |             ^^^^^^^^^^^^^^^^^^ method cannot be called on `&fancy_regex::Error` due to unsatisfied trait bounds\\r\\n   |\\r\\n  ::: /home/prophet/.cargo/registry/src/github.com-1ecc6299db9ec823/fancy-regex-0.1.0/src/lib.rs:52:1\\r\\n   |\\r\\n52 | pub enum Error {\\r\\n   | --------------\\r\\n   | |\\r\\n   | doesn't satisfy `_: thiserror::__private::AsDynError`\\r\\n   | doesn't satisfy `fancy_regex::Error: std::error::Error`\\r\\n   |\\r\\n   = note: the following trait bounds were not satisfied:\\r\\n           `fancy_regex::Error: std::error::Error`\\r\\n           which is required by `fancy_regex::Error: thiserror::__private::AsDynError`\\r\\n           `&fancy_regex::Error: std::error::Error`\\r\\n           which is required by `&fancy_regex::Error: thiserror::__private::AsDynError`\\r\\n\\r\\nerror[E0599]: the method `as_display` exists for reference `&fancy_regex::Error`, but its trait bounds were not satisfied\\r\\n  --> src/lib.rs:62:13\\r\\n   |\\r\\n62 |     #[error(\\\"Regex error: {0}\\\")]\\r\\n   |             ^^^^^^^^^^^^^^^^^^ method cannot be called on `&fancy_regex::Error` due to unsatisfied trait bounds\\r\\n   |\\r\\n  ::: /home/prophet/.cargo/registry/src/github.com-1ecc6299db9ec823/fancy-regex-0.1.0/src/lib.rs:52:1\\r\\n   |\\r\\n52 | pub enum Error {\\r\\n   | -------------- doesn't satisfy `fancy_regex::Error: std::fmt::Display`\\r\\n   |\\r\\n   = note: the following trait bounds were not satisfied:\\r\\n           `fancy_regex::Error: std::fmt::Display`\\r\\n           which is required by `&fancy_regex::Error: thiserror::__private::DisplayAsDisplay`\\r\\n```\\r\\n\\r\\nSince this works out of the box for std's regexes, it would make it easier to switch to fancy-regex if this worked.\", \"comments\": [{\"author\": \"BurntSushi\", \"body\": \"When reporting bugs, it is much more helpful to provide a *complete* reproduction whenever possible. Show your entire program (ideally as small as possible to demonstrate the problem), any inputs, actual output, expected output and the commands you used to build and run the program.\\r\\n\\r\\nCase in point, notice this string in your error message:\\r\\n\\r\\n> fancy-regex-0.1.0\\r\\n\\r\\nThat version is ancient. So the problem here is not as you say, but elsewhere. Without a complete reproduction, it is impossible to say where things have gone wrong.\"}, {\"author\": \"jgarvin\", \"body\": \"I later ran into it complaining `Display` wasn't implemented, which directly contradicted the docs, and realized I had:\\r\\n\\r\\n`fancy_regex = \\\"0.1\\\"`\\r\\n\\r\\nNot:\\r\\n\\r\\n`fancy_regex = \\\"0.10\\\"`\\r\\n\\r\\nü§¶\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_109", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"109\", \"title\": \"this lookbehind (?<=(.|^)) causes \\\"CompileError(LookBehindNotConst)\\\"\", \"author\": \"ezw678\", \"labels\": [], \"description\": \"this is the complete regex: \\\".*?(?=XY)(?<=(.|^))XY(?=(.|$))|.+\\\". If I remove |^ or remove .| as follows:\\r\\n\\r\\n\\\".*?(?=XY)(?<=(.))XY(?=(.|$))|.+\\\"\\r\\n\\\".*?(?=XY)(?<=(^))XY(?=(.|$))|.+\\\"\\r\\n\\r\\nit will compile but the result is not correct.\\r\\n\\r\\nPlease take a look. Thanks!\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"a similar issue was reported here: https://github.com/fancy-regex/fancy-regex/issues/74\\r\\n\\r\\nthe workaround at the moment is to repeat the pattern up to that point:\\r\\n`\\\"(?:.*?(?<=.)|.*?(?<=^))(?=XY)XY(?=(.|$))|.+`\\r\\n\\r\\nbut I confess I don't understand your pattern at all, `^|.` will always be true...\"}, {\"author\": \"ezw678\", \"body\": \"good idea. it works;\\r\\n\\r\\n.*?(?=XY)(?:(?<=(^))|(?<=(.)))XY(?=(.|$))|.+\\r\\n\\r\\nthis is to extract a letter before and after, if existing, a given string, \\\"XY\\\" in this case.\\r\\nthanks a lot!!!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_112", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"112\", \"title\": \"Support Octal escapes\", \"author\": \"mdecimus\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nI am writing a tool that needs to be able parse and evaluate regular expressions originally written for Perl. Overall the library works great but I am getting an `Invalid back reference` error when trying to parse the following regex:\\r\\n\\r\\n```regex\\r\\n[\\\\042\\\\223\\\\224\\\\262\\\\263\\\\271]{2}\\\\S{0,16}[\\\\042\\\\223\\\\224\\\\262\\\\263\\\\271]{2}\\r\\n```\\r\\n\\r\\nThis regex is parsed properly by Perl and also online tools such as regex101.com. To make it work on `fancy-regex` I need to replace the octal references with their corresponding Unicode sequences:\\r\\n\\r\\n```regex\\r\\n[\\\\\\\"\\\\u{93}\\\\u{94}\\\\u{B2}\\\\u{B3}\\\\u{B9}]{2}\\\\S{0,16}[\\\\\\\"\\\\u{93}\\\\u{94}\\\\u{B2}\\\\u{B3}\\\\u{B9}]{2}\\r\\n```\\r\\n\\r\\nNot a big deal, but I am opening this issue in case you consider not being able to parse those octal codes a bug in the library.\\r\\n\\r\\nThanks.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"We try to be compatible with Oniguruma syntax, which supports octal, so this is something we might add. How does Perl disambiguate between `\\\\1` being a backreference vs octal?\"}, {\"author\": \"mdecimus\", \"body\": \"> We try to be compatible with Oniguruma syntax, which supports octal, so this is something we might add. How does Perl disambiguate between `\\\\1` being a backreference vs octal?\\r\\n\\r\\nI've never used Perl so I can't say for sure but this is how I think it works:\\r\\n\\r\\n- A back reference refers to a previously matched capturing group.\\r\\n- If the character after the backslash is a number and doesn't conform to the octal format (especially if it doesn't start with `0`), then Perl interprets it as a back reference. For example, `\\\\1` would refer to the first capturing group.\\r\\n\\r\\nI've just found another valid Perl regular expression that can't be parsed by `fancy-regex`:\\r\\n\\r\\n```regex\\r\\n/[({[<][. ]*(?-i:\\\\xbc\\\\xba[. ]*\\\\xc0\\\\xce[. ]*)?(?-i:\\\\xb1\\\\xa4(?:[. ]*|[\\\\x00-\\\\x7f]{0,3})\\\\xb0\\\\xed|\\\\xc1\\\\xa4[. ]*\\\\xba\\\\xb8|\\\\xc8\\\\xab[. ]*\\\\xba\\\\xb8)[. ]*[)}\\\\]>]/\\r\\n```\\r\\n\\r\\nI had to escape every special character so it could be parsed:\\r\\n\\r\\n```regex\\r\\n/[\\\\(\\\\{\\\\[\\\\<][. ]*(?-i:\\\\xbc\\\\xba[. ]*\\\\xc0\\\\xce[. ]*)?(?-i:\\\\xb1\\\\xa4(?:[. ]*|[\\\\x00-\\\\x7f]{0,3})\\\\xb0\\\\xed|\\\\xc1\\\\xa4[. ]*\\\\xba\\\\xb8|\\\\xc8\\\\xab[. ]*\\\\xba\\\\xb8)[. ]*[\\\\)\\\\}\\\\]\\\\>]/\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"}, {\"author\": \"BurntSushi\", \"body\": \"I'm not involved with fancy-regex (but I'm the author of `regex` on which this crate is built), and I can say that you're going to have a bad time if you assume any two regex engines are going to accept the same syntax. And even if they accept the same syntax, they may still behave differently.\\r\\n\\r\\nMaybe a case here and there can be smoothed out, but in general, if you need to be able to \\\"parse and match regexes written for Perl,\\\" then I think you have three choices:\\r\\n\\r\\n1. Use Perl.\\r\\n2. Spend an enormous amount of effort translating regexes from the Perl flavor to the fancy-regex flavor. (This may actually be a Sysphean task.)\\r\\n3. Drop the requirement or \\\"be okay\\\" with some regexes not working.\\r\\n\\r\\n(This same discussion has repeated itself several times in different forms on the regex crate repo.)\"}, {\"author\": \"robinst\", \"body\": \"Looks like onig doesn't require a leading 0, need to check what it does when it's ambiguous: https://github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#28-onig_syn_op_esc_octal3-enable-ooo-octal-codes\"}, {\"author\": \"mdecimus\", \"body\": \"> I'm not involved with fancy-regex (but I'm the author of regex on which this crate is built), and I can say that you're going to have a bad time if you assume any two regex engines are going to accept the same syntax. And even if they accept the same syntax, they may still behave differently.\\r\\n\\r\\nI am currently porting SpamAssassin to Rust, which relies on hundreds of Perl regular expressions (many of them very inefficient) so my plan is to replace with native code those regexes that don't work on `fancy-regex` or are inefficient (such as `/<!--(?:\\\\s{1,10}[-\\\\w'\\\"]{1,40}){100}/im`).\\r\\n\\r\\nI have already fixed all the expressions that couldn't be parsed, I just opened this issue in case the author(s) wanted to support a syntax that Perl and other engines consider valid.\\r\\n\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_113", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"113\", \"title\": \"Why are Expander's fields private?\", \"author\": \"mindreader\", \"labels\": [], \"description\": \"I want to use a slightly different expansion method, the default, but with `allow_undelimited_name: false`, but I can't see a way to do it with the public api available.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"I would guess that the idea is to only expose things we know will be used, because once something is public we need to be more careful when making changes etc. and support various previously unthought of interactions.\\r\\n\\r\\nI'd say open a PR, and then we can get more of an idea of how much maintenance burden it could add.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_114", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"114\", \"title\": \"Is serialization supported?\", \"author\": \"ZJaume\", \"labels\": [], \"description\": \"Is serialization like https://docs.rs/serde_regex/latest/serde_regex/ supported or acan be achieved some way?\", \"comments\": [{\"author\": \"ZJaume\", \"body\": \"Sorry, I now see that `serde_regex` is independent from regex, so maybe it should be `serde_regex` or a fork from it who implements this. I noticed that the serialization needs `regex::bytes` and `regex::RegexSet` and that is discussed here #84 . So I guess I close this.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_122", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"122\", \"title\": \"Fuzzing results in index out of bounds\", \"author\": \"manunio\", \"labels\": [], \"description\": \"#### Description\\r\\nHi, Running fuzz_parser results in following error.\\r\\n`thread '<unnamed>' panicked at 'index out of bounds: the len is 5 but the index is 6', /home/maxx/dev/security/oss-fuzz-projects/fancy-regex/src/parse.rs:774:19`\\r\\n\\r\\n#### Steps to reproduce\\r\\n```rust\\r\\n#[test]\\r\\nfn fuzz_3() {\\r\\n    p(r\\\"(?()^\\\");\\r\\n}\\r\\n```\\r\\n\\r\\n```sh\\r\\n‚ùØ cargo test parse::tests::fuzz_3\\r\\n```\\r\\n\\r\\n```\\r\\nCompiling fancy-regex v0.12.0 (/home/maxx/dev/security/oss-fuzz-projects/fancy-regex)\\r\\nFinished test [unoptimized + debuginfo] target(s) in 2.78s\\r\\nRunning unittests src/lib.rs (target/debug/deps/fancy_regex-fcae9c14f84f520b)\\r\\n\\r\\nrunning 1 test\\r\\ntest parse::tests::fuzz_3 ... FAILED\\r\\n\\r\\nfailures:\\r\\n\\r\\n---- parse::tests::fuzz_3 stdout ----\\r\\nthread 'parse::tests::fuzz_3' panicked at 'index out of bounds: the len is 5 but the index is 6', src/parse.rs:774:19\\r\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\r\\n\\r\\n\\r\\nfailures:\\r\\n    parse::tests::fuzz_3\\r\\n\\r\\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 73 filtered out; finished in 0.00s\\r\\n\\r\\nerror: test failed, to rerun pass `--lib`\\r\\n\\r\\n```\\r\\n\", \"comments\": [{\"author\": \"joshfried-aws\", \"body\": \"I have also come across 2 such instances \\r\\n\\r\\nThe first occurs when using control characters eg: \\r\\n```\\r\\nlet regex = Regex::try_from(r#\\\"  (FF\\\\0\\\\0\\\\0\\\\0\\\\0\\\\0()!\\\\u{f}t\\\\t(?(\\\\n{),:?\\\\u{f}\\\\n                \\\"#);\\r\\n```\\r\\n\\r\\nI believe this second example is due to an incomplete capturing group. \\r\\n\\r\\n```\\r\\nlet regex = Regex::try_from(r#\\\"!w(?()\\\\\\\"Kuz>\\\"#);\\r\\n```\"}, {\"author\": \"robinst\", \"body\": \"Thanks, fix is in review:\\r\\n* https://github.com/fancy-regex/fancy-regex/pull/125\"}, {\"author\": \"joshfried-aws\", \"body\": \"Hi @robinst this still doesnt handle the case where there are control characters, correct? \"}, {\"author\": \"robinst\", \"body\": \"@joshfried-aws It does. I tested that one, but the cause is the same as the others, the conditional `(?(`.\"}, {\"author\": \"manunio\", \"body\": \"Hi @robinst after applying the fix, i'm getting a `index out of bound` with different test case.\\r\\n```rust\\r\\n#[test]\\r\\nfn fuzz_4() {\\r\\n    p(r\\\"\\\\u{2}(?(2)\\\");\\r\\n}\\r\\n```\\r\\n\\r\\n```\\r\\nfailures:\\r\\n\\r\\n---- parse::tests::fuzz_4 stdout ----\\r\\nthread 'parse::tests::fuzz_4' panicked at 'index out of bounds: the len is 10 but the index is 11', src/parse.rs:774:19\\r\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\r\\n\\r\\n\\r\\n```\\r\\nEdit:\\r\\nSorry for just posting errors here; wish i could help with the fix :/\"}, {\"author\": \"robinst\", \"body\": \"Thanks, also fixed :).\"}, {\"author\": \"joshfried-aws\", \"body\": \"@robinst thank you for this. Any idea when the next release will be live so I can update my crate that has a dependency on fancy-regex? \"}, {\"author\": \"robinst\", \"body\": \"> @robinst thank you for this. Any idea when the next release will be live so I can update my crate that has a dependency on fancy-regex?\\r\\n\\r\\nYep, I'm planning to release this in the next few days.\"}, {\"author\": \"robinst\", \"body\": \"Released in 0.13.0 now: https://github.com/fancy-regex/fancy-regex/blob/0.13.0/CHANGELOG.md#0130---2023-12-22\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_123", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"123\", \"title\": \"Unable to download v0.12.0\", \"author\": \"t1000ln\", \"labels\": [], \"description\": \"Hello, I am unable to download the v0.12.0 package from the mirror server of Crates io and it always makes an error.\\r\\nI tried changing several mirror servers within China but couldn't download it.\\r\\n```bash\\r\\nstdout :  Downloading crates ...\\r\\nwarning: spurious network error (3 tries remaining): [92] Stream error in the HTTP/2 framing layer (HTTP/2 stream 1 was not closed cleanly: INTERNAL_ERROR (err 2))\\r\\nwarning: spurious network error (2 tries remaining): [92] Stream error in the HTTP/2 framing layer (HTTP/2 stream 3 was not closed cleanly: INTERNAL_ERROR (err 2))\\r\\nwarning: spurious network error (1 tries remaining): [92] Stream error in the HTTP/2 framing layer (HTTP/2 stream 5 was not closed cleanly: INTERNAL_ERROR (err 2))\\r\\nerror: failed to download from `https://crates-io.proxy.ustclug.org/api/v1/crates/fancy-regex/0.12.0/download`\\r\\n```\\r\\n\\r\\nBut v0.11.0 can be successfully downloaded.\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_124", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"124\", \"title\": \"Is it possible to search backward ?\", \"author\": \"kukuro-kt\", \"labels\": [], \"description\": \"I tried to use `find_iter(...).rev()` but got error:\\r\\n```\\r\\nfn rev(self) -> Rev<Self>\\r\\n     |        --- required by a bound in this associated function\\r\\n3397 |     where\\r\\n3398 |         Self: Sized + DoubleEndedIterator,\\r\\n     |                       ^^^^^^^^^^^^^^^^^^^ required by this bound in `Iterator::rev`\\r\\n```\", \"comments\": [{\"author\": \"robinst\", \"body\": \"That's not possible, no. Looks like not even the regex crate supports that?: https://docs.rs/regex/latest/regex/struct.Matches.html\"}, {\"author\": \"BurntSushi\", \"body\": \"Correct, it does not. It is theoretically possible to do, but an absolute mammoth undertaking.\\r\\n\\r\\nIt is possible, today, to do some amount of reverse searching with the DFA engines. But it's not a nicely supported workflow and you'll be limited to finding matches only. If someone wanted help with that, they could ask a Discussion question on the regex crate repo.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_127", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"127\", \"title\": \"Propagate errors in `replace` instead of using unwrap\", \"author\": \"kevinhu\", \"labels\": [], \"description\": \"I'm using a couple of lookahead expressions in a text cleaning library I've been working on, and sometimes these run into backtrack limits (`RuntimeError::BacktrackLimitExceeded`). When this happens inside the `replace_all` function, the `.unwrap` call (this [line](https://github.com/fancy-regex/fancy-regex/blob/main/src/lib.rs#L974)) causes a panic that's hard to handle.\\r\\n\\r\\nWould it be possible to have `replacen` or an alternative return a `Result` that propagates these errors?\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Yep, that makes sense! Maybe it could be called`try_replacen`? The existing `replacen` would then call that and do an `unwrap()` on it, should be pretty straightforward.\\r\\n\\r\\nDo you feel comfortable making that change?\"}, {\"author\": \"kevinhu\", \"body\": \"Sure! I've opened a PR here: https://github.com/fancy-regex/fancy-regex/pull/130\"}, {\"author\": \"robinst\", \"body\": \"Thanks! Released in 0.13.0 now: https://github.com/fancy-regex/fancy-regex/blob/0.13.0/CHANGELOG.md#0130---2023-12-22\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_133", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"133\", \"title\": \"Export `parse` related utilities\", \"author\": \"tristan-f-r\", \"labels\": [\"enhancement\"], \"description\": \"`fancy-regex` is the only rust crate that has generic regex syntax support; exporting the parse utilities / bundling it as its own crate would be quite nice.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"FYI, this is something we plan to get to sometime after we support subexpressions and recursion. It will probably take some work to get the API in a good enough and stable enough state to make public. Maybe it will also be necessary for https://github.com/fancy-regex/fancy-regex/issues/176.\\n\\nSome ideas of what needs to be done:\\n- add  an`Expr` for a named backref instead of resolving it at parse time\\n  - same for subroutine calls\\n  - resolve them during the analysis step instead\\n- [ ] track multiple groups with the same name: https://github.com/fancy-regex/fancy-regex/issues/177\\n- keep comments and insignificant whitespace in the `ExprTree`?\\n- create specific `Expr` nodes instead of putting everything in the `Delegate` variant, like character classes etc.\\n- store the location each `Expr` was parsed from in case the caller wants to do something like show a live explanation of what each `Expr` means when the user has the text caret there etc, but in such a way that it can easily be dropped without affecting performance or complicating the code which doesn't need to know such details\\n  - note: probably we would also need `Expr`s for flag groups, but then it gets complicated if someone changes flags after the regex pattern has been parsed because they might expect it to affect the following `Expr`s... Perhaps some resolving of casei etc should be done at analysis time instead of parse time and being put in `Literal`?\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_134", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"134\", \"title\": \"Inconsistent Backtrack Limit Handling in Regex Matching\", \"author\": \"l0rinc\", \"labels\": [], \"description\": \"The following reproducer:\\r\\n```\\r\\n    #[test]\\r\\n    fn test_effect_of_backtrack_limit() {\\r\\n        const INPUT_LIMIT: usize = 10;\\r\\n        const INPUT_SIZE: usize = 100;\\r\\n        let regex = RegexBuilder::new(r\\\"(a|b|ab)*(?=c)\\\")\\r\\n            .backtrack_limit(INPUT_LIMIT)\\r\\n            .build()\\r\\n            .expect(\\\"Failed to build regex\\\")\\r\\n            .clone();\\r\\n\\r\\n        let input = \\\"ab\\\".repeat(INPUT_SIZE) + \\\"c\\\";\\r\\n        assert!(regex.is_match(&input).is_err(), \\\"Should throw\\\");\\r\\n    }\\r\\n```\\r\\nfails correctly at\\r\\n```\\r\\n        if backtrack_count > options.backtrack_limit {\\r\\n            return Err(Error::RuntimeError(RuntimeError::BacktrackLimitExceeded));\\r\\n        }\\r\\n```\\r\\n\\r\\nbut if we increase the SIZE and make the limit a lot bigger, it should not throw, but it panics (is it a simple stack overflow now?):\\r\\n```\\r\\n    #[test]\\r\\n    fn test_effect_of_backtrack_limit() {\\r\\n        const INPUT_LIMIT: usize = 10_000_000;\\r\\n        const INPUT_SIZE: usize = 1_000_000;\\r\\n        let regex = RegexBuilder::new(r\\\"(a|b|ab)*(?=c)\\\")\\r\\n            .backtrack_limit(INPUT_LIMIT)\\r\\n            .build()\\r\\n            .expect(\\\"Failed to build regex\\\")\\r\\n            .clone();\\r\\n\\r\\n        let input = \\\"ab\\\".repeat(INPUT_SIZE) + \\\"c\\\";\\r\\n        assert!(regex.is_match(&input).is_ok(), \\\"Should not throw\\\");\\r\\n    }\\r\\n```\\r\\n\\r\\nIs there a way to increase the backtracking limit to 10 million in e.g. https://github.com/openai/tiktoken/issues/245?\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hi! Yeah, it's a stack overflow. Changing the assert to this:\\r\\n\\r\\n```rust\\r\\nprintln!(\\\"{:?}\\\", regex.is_match(&input));\\r\\n```\\r\\n\\r\\nPrints:\\r\\n```\\r\\n$ cargo test test_effect_of_backtrack_limit -- --show-output\\r\\n...\\r\\nErr(RuntimeError(StackOverflow))\\r\\n```\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_135", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"135\", \"title\": \"Missing regex flag `(?R)`\", \"author\": \"CAD97\", \"labels\": [], \"description\": \"fancy-regex errors on the flag with `UnknownFlag(\\\"(?R\\\")`. The [`regex` crate describes `?R`](https://docs.rs/regex/latest/regex/#grouping-and-flags) as:\\r\\n\\r\\n> <dl><dt>R</dt><dd>enables CRLF mode: when multi-line mode is enabled, \\\\r\\\\n is used</dd></dl>\\r\\n>\\r\\n>When both CRLF mode and multi-line mode are enabled, then `^` and `$` will match either `\\\\r` [[or]](https://github.com/rust-lang/regex/pull/1165) `\\\\n`, but never in the middle of a \\\\r\\\\n:\\r\\n> ```\\r\\n> use regex::Regex;\\r\\n> let re = Regex::new(r\\\"(?mR)^foo$\\\").unwrap();\\r\\n> let m = re.find(\\\"\\\\r\\\\nfoo\\\\r\\\\n\\\").unwrap();\\r\\n> assert_eq!(m.as_str(), \\\"foo\\\");\\r\\n> ```\", \"comments\": [{\"author\": \"CAD97\", \"body\": \"would be fixed by #131\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_136", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"136\", \"title\": \"Missing regex special word boundary escapes\", \"author\": \"CAD97\", \"labels\": [\"enhancement\", \"help wanted\", \"good first issue\"], \"description\": \"Specifically, `\\\\b{start}`, `\\\\b{end}`, `\\\\b{start-half}`, `\\\\b{end-half}`. fancy-regex errors when encountering one of these with `InvalidEscape(\\\"\\\\\\\\b\\\")`. The directional boundary assertions are available as `\\\\<`/`\\\\>`, but the half-boundary assertions aren't accessible except via lookaround (`(?<=\\\\W|\\\\A)`/`(?=\\\\W|\\\\z)`).\", \"comments\": [{\"author\": \"robinst\", \"body\": \"regex-automata supports these (see [LookMatcher](https://docs.rs/regex-automata/latest/regex_automata/util/look/struct.LookMatcher.html)), so adding support for these should be straightforward, see e.g. how `Assertion::LeftWordBoundary` is done (and parsing). Added the \\\"help wanted\\\" label if anyone wants to give it a try and open a PR.\"}, {\"author\": \"k94-ishi\", \"body\": \"I gave it a try and opened a PR here: #193.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_137", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"137\", \"title\": \"`find_iter()` stuck in infinite loop after `Error::BacktrackLimitExceeded` occurs\", \"author\": \"andrewhalle\", \"labels\": [\"help wanted\"], \"description\": \"The following code infinite loops.\\r\\n\\r\\n```rust\\r\\nuse fancy_regex::RegexBuilder;\\r\\n\\r\\nfn main() {\\r\\n    let r = RegexBuilder::new(\\\"(x+x+)+(?=y)\\\")\\r\\n        .backtrack_limit(1)\\r\\n        .build()\\r\\n        .unwrap();\\r\\n    let _: Vec<_> = r.find_iter(\\\"xxxxxxxxxxy\\\").collect();\\r\\n    println!(\\\"done!\\\");\\r\\n}\\r\\n```\\r\\n\\r\\nWe encountered this in code that we didn't know was hitting the default backtracking limit. It's possible to catch this by changing the type of the collection to `Result<Vec<_>, _>`, but it seems like an easy mistake to make.\\r\\n\\r\\nGiven that it doesn't seem possible to recover from a `BacktrackLimitExceeded` error, would it be reasonable to have `find_iter()`and `captures_iter()` stop iteration when they encounter such an error? It could also simply be a documentation opportunity on `find_iter()` and `captures_iter()`.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"Hm yeah I see how that can be confusing. And re-attempting the match at the same position doesn't make sense anyway, as it will fail again. I think there's two things we could do here:\\r\\n\\r\\n1. Stop on first error: If an error is encountered, return it, and set the \\\"last match position\\\" to the string length, so that the next `next()` call will return `None`.\\r\\n2. Advance on error: Return the error, but also advance the index by one so that the next attempt will try from there.\\r\\n\\r\\nI feel like 1 is better because it's predictable and simple to explain. 2 might return matches that don't make sense depending on the input string. What do you think?\"}, {\"author\": \"andrewhalle\", \"body\": \"I think 1 makes sense to me!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_138", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"138\", \"title\": \"Version 0.13.0 throws an Error::BacktrackLimitExceeded\", \"author\": \"jcold\", \"labels\": [], \"description\": \"The following code snippet works fine in v0.12.0, but in v0.13.0 it throws an Error::BacktrackLimitExceeded. The regex crates have been checked and they are fine. Any assistance would be appreciated.\\r\\n\\r\\nerror message: `Error executing regex: Max limit for backtracking count exceeded`\\r\\n\\r\\n```rust\\r\\n#[test]\\r\\nfn fancy() -> anyhow::Result<()> {\\r\\n    let re = fancy_regex::Regex::new(r\\\"\\\\b\\\\$?t\\\\('(.+?)'\\\\)\\\")?;\\r\\n    for m in re.captures_iter(\\\"content...\\\") {\\r\\n        if let Some(v) = m?.get(1) {\\r\\n            println!(\\\"{}\\\", v.as_str().to_string());\\r\\n        }\\r\\n    }\\r\\n    Ok(())\\r\\n}\\r\\n```\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"hmm, I tried to reproduce this with the `toy` example and wasn't able to:\\r\\n\\r\\n```sh\\r\\ncargo run --example toy -- run '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' 'content...'\\r\\n```\\r\\n\\r\\n>\\r\\n```\\r\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.03s\\r\\n     Running `target/debug/examples/toy run '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' content...`\\r\\nno match\\r\\n```\"}, {\"author\": \"Guillermogsjc\", \"body\": \"Hi folks,\\r\\n\\r\\nI'm also encountering this issue with complex, user-defined regex patterns (bad practices, horrible pattern), such as:\\r\\n\\r\\n`(a\\\\w?).*?(b\\\\w?).*?(c\\\\w?).*?(d\\\\w?).*?(e\\\\w?).*?(f\\\\w?).*?(g\\\\w?).*?(h\\\\w?).*?(i\\\\w?).*?(j\\\\w*).*?(k\\\\w?).*?(l\\\\w?)`\\r\\n\\r\\nThe error RuntimeError(BacktrackLimitExceeded) frequently occurs when using fancy_regex==0.13.0, compared to 0.12.0.\\r\\n\\r\\nI‚Äôm aware that the backtracking limit can be increased here: https://docs.rs/fancy-regex/latest/fancy_regex/struct.RegexBuilder.html#method.backtrack_limit, but the question is: why does this error happen much more often in this version than in the previous one? It seems like the internals are consuming significantly more resources or states.\\r\\n\\r\\nI suspect this is related to the switch from the `regex` crate to the lower-level `regex-automata`. Perhaps something is missing in how greedy particles like `.*` are being handled.\\r\\n\\r\\n> https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#0130---2023-12-22\\r\\n> \\r\\n> Switch from the regex crate to regex-automata and regex-syntax (lower-level APIs) to simplify internals (#121)\\r\\n\\r\\n\"}, {\"author\": \"keith-hall\", \"body\": \"Thanks for reporting with an additional example. I unfortunately have very little free time these days to investigate. I wonder if the different `toy` examples give different output in the version of `fancy-regex` before the `regex-automata` change compared to after, and whether that would give any clues as to the cause...\"}, {\"author\": \"robinst\", \"body\": \"I had a look at the first example by @jcold. The difference seems to be caused by the `\\\\b` for that one:\\r\\n\\r\\n```\\r\\n$ git switch --detach 0.12.0\\r\\n$ cargo run --example toy -- trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' 'content...'\\r\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.85s\\r\\n    Running `target/debug/examples/toy trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' content...`\\r\\npos\\tinstruction\\r\\n0\\t0 Delegate { inner: Regex(\\\"^\\\\\\\\b\\\\\\\\$?t\\\\\\\\('(.+?)'\\\\\\\\)\\\"), inner1: Some(Regex(\\\"^(?s:.)\\\\\\\\b\\\\\\\\$?t\\\\\\\\('(.+?)'\\\\\\\\)\\\")), start_group: 0, end_group: 1 }\\r\\nfail\\r\\n```\\r\\n\\r\\nSo 0.12.0 delegates the entire expression. Whereas 0.13.0 doesn't delegate the WordBoundary:\\r\\n\\r\\n```\\r\\n$ git switch --detach 0.13.0\\r\\n$ cargo run --example toy -- trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' 'content...'\\r\\n    Finished dev [unoptimized + debuginfo] target(s) in 0.05s\\r\\n     Running `target/debug/examples/toy trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' content...`\\r\\npos\\tinstruction\\r\\n0\\t0 Assertion(WordBoundary)\\r\\n0\\t1 Delegate ...\\r\\n...\\r\\n```\\r\\n\\r\\n@ruihe774 Thoughts about this? I would probably go back to delegating word boundary matches again.\"}, {\"author\": \"ruihe774\", \"body\": \"> I had a look at the first example by @jcold. The difference seems to be caused by the `\\\\b` for that one:\\r\\n> \\r\\n> ```\\r\\n> $ git switch --detach 0.12.0\\r\\n> $ cargo run --example toy -- trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' 'content...'\\r\\n>     Finished dev [unoptimized + debuginfo] target(s) in 0.85s\\r\\n>     Running `target/debug/examples/toy trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' content...`\\r\\n> pos\\tinstruction\\r\\n> 0\\t0 Delegate { inner: Regex(\\\"^\\\\\\\\b\\\\\\\\$?t\\\\\\\\('(.+?)'\\\\\\\\)\\\"), inner1: Some(Regex(\\\"^(?s:.)\\\\\\\\b\\\\\\\\$?t\\\\\\\\('(.+?)'\\\\\\\\)\\\")), start_group: 0, end_group: 1 }\\r\\n> fail\\r\\n> ```\\r\\n> \\r\\n> So 0.12.0 delegates the entire expression. Whereas 0.13.0 doesn't delegate the WordBoundary:\\r\\n> \\r\\n> ```\\r\\n> $ git switch --detach 0.13.0\\r\\n> $ cargo run --example toy -- trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' 'content...'\\r\\n>     Finished dev [unoptimized + debuginfo] target(s) in 0.05s\\r\\n>      Running `target/debug/examples/toy trace '\\\\b\\\\$?t\\\\('\\\\''(.+?)'\\\\''\\\\)' content...`\\r\\n> pos\\tinstruction\\r\\n> 0\\t0 Assertion(WordBoundary)\\r\\n> 0\\t1 Delegate ...\\r\\n> ...\\r\\n> ```\\r\\n> \\r\\n> @ruihe774 Thoughts about this? I would probably go back to delegating word boundary matches again.\\r\\n\\r\\nLet me look into this.\"}, {\"author\": \"ruihe774\", \"body\": \"I'd suggest to increase the backtrack limit.\\r\\n\\r\\nIf we delegate the word boundary assertions to `Regex`, it will switch to use PikeVM, which is also a backtrack-based regex virtual machine and is slower than the default DFA/NFA implementation.\\r\\n\\r\\nThe total times of backtracking does not change. It is just that in previous implementation we delegated some backtracking to the underlying PikeVM of `Regex`, and we did not measure the times of backtracking in PikeVM. In current implementation, the backtracking is moved from PikeVM to the VM of fancy-regex, hence the measured times of backtracking increase. \\r\\n\\r\\nThere is no performance regression or memory usage regression.\"}, {\"author\": \"Guillermogsjc\", \"body\": \"> The total times of backtracking does not change. It is just that in previous implementation we delegated some backtracking to the underlying PikeVM of Regex, and we did not measure the times of backtracking in PikeVM. In current implementation, the backtracking is moved from PikeVM to the VM of fancy-regex, hence the measured times of backtracking increase.\\r\\n\\r\\nThats it, perfect, thanks for the explanation . Maybe warn on changelog to expect a need on increasing this limit that can be hitten more easily (as it counts more backtracks that were done under the hoods before) after upgrading to 0.13.0 from <0.13.0.  It would reduce future noise on issues about this subject.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_141", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"141\", \"title\": \"Recursive Expressions (?R) in Rust's fancy-regex\", \"author\": \"levish0\", \"labels\": [], \"description\": \"I've looked through several regex crates in Rust (rust-onig / regex,,). but I haven't seen any that implement recursive expressions `(?R)` (to parse syntax like `{{{((?:[^{}]*|(?R))+)}}}`) yet. The README mentions that this feature is still in development, and while the basic ideas are in place, it states that procedure calls and recursive expressions are currently missing. \\r\\n\\r\\nDo you have any updates or timelines regarding when this functionality might be implemented?\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Hi, thanks for your interest. I have the idea that the readme is misleading unfortunately - I don't know of anyone actively working on this feature. And I personally don't think I will have time to work on recursive expressions any time soon. Contributions are very welcome, however üôÇ\"}, {\"author\": \"levish0\", \"body\": \"Thanks for the quick response and clarification!\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_142", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"142\", \"title\": \"Exposing an automaton\", \"author\": \"hendrikvanantwerpen\", \"labels\": [], \"description\": \"üëãüèª Thanks for developing this crate!\\n\\nI was wondering if there are any plans to expose underlying automatons? An example is the [regex-automata](https://crates.io/crates/regex-automata) crate that does this for `regex` supported regular expressions.\\n\\nOur use case is that we are building up a text incrementally and want to keep track of regex matches while we are building it up. Re-executing the regex every time on the updated text would be too slow for our application.\", \"comments\": [{\"author\": \"robinst\", \"body\": \"There are no plans for that at the moment. Can you elaborate a bit more? What would the API look like?\"}, {\"author\": \"hendrikvanantwerpen\", \"body\": \"The internals of the `regex` crate have such an interface: <https://docs.rs/regex-automata/latest/regex_automata/dfa/trait.Automaton.html>. The idea is that you have control over transitioning through the state. A sketch of a minimal set of operations is something like this:\\n\\n    initial_state() -> State\\n    next_state(State) -> State\\n    is_match_state(State) -> bool\\n    is_dead_state(State) -> bool\\n\\nOne of the things this enables is incremental matching while building a string and for example aborting the string building if it doesn't match the regex (ends in a dead state).\\n\\nI wonder if the interface from `regex-automata` is flexible enough for this crate. Probably not because the look-around is different, not restricted to a single byte.\"}, {\"author\": \"BurntSushi\", \"body\": \"@hendrikvanantwerpen That's an API for one very specific type of regex engine: a pure DFA. If you look around the rest of `regex-automata`, you'll see other regex engines with different APIs. Consider the [`PikeVM`](https://docs.rs/regex-automata/latest/regex_automata/nfa/thompson/pikevm/struct.PikeVM.html) for example, which is much more coarsely grained and gives a lot less control. I would expect `fancy-regex`'s internals to look more like the latter than the former.\"}, {\"author\": \"BurntSushi\", \"body\": \"And also, as the author of `regex-automata`, it took me about 3 years of off-and-on work to complete. I don't know if it would be the same amount of work for `fancy-regex`, but it's a pretty big task.\"}, {\"author\": \"hendrikvanantwerpen\", \"body\": \"@BurntSushi Thanks for the pointers---I hadn't realized that the other flavors did not have similar automata defined.\\n\\nTo be clear, this was more a question out of interest than a strong suggestion :) I didn't think through the technical details at all, and certainly appreciate the effort it would take if the code isn't already structured like that under the hood.\\n\\nThe concrete problem that inspired this was solved differently in the end. Since the regexes only had a one-character lookahead, we used the `regex-automata` DFA with just a little bit of logic around it.\"}, {\"author\": \"robinst\", \"body\": \"Thanks @BurntSushi! Closing this.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_147", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"147\", \"title\": \"Matching for \\\\Z does not work\", \"author\": \"hoanbui29\", \"labels\": [\"enhancement\", \"help wanted\"], \"description\": \"My regex: Regex::new(r\\\"(?<=do\\\\(\\\\)|\\\\A)[\\\\s\\\\S]*?(?=don\\\\'t\\\\(\\\\)|\\\\Z)\\\").unwrap();\\r\\n\\r\\nError: thread 'main' panicked at src/main.rs:21:81:\\r\\ncalled `Result::unwrap()` on an `Err` value: ParseError(36, InvalidEscape(\\\"\\\\\\\\Z\\\"))\\r\\n\\r\\nIt seems like matching for end of string (\\\\Z) does not work as expected.\\r\\n\\r\\n![CleanShot 2024-12-04 at 10 58 22@2x](https://github.com/user-attachments/assets/3a0d1f60-9807-4ec4-a750-24171dd7b492)\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Indeed, [Oniguruma supports it](https://github.com/kkos/oniguruma/blob/c4a55f8363dfd4c60320000871c6de44b28615fc/doc/RE#L180) but the `regex` crate and `fancy-regex`  only support `\\\\z`. \\r\\nAs `fancy-regex` generally tries to be compatible with Oniguruma syntax, it makes sense to add support for it.\\r\\nHere is how `fancy-regex` currently handles `\\\\z`, in case it helps someone work out where to start:\\r\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/parse.rs#L352-L353\\r\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/vm.rs#L495\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_149", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"149\", \"title\": \"Regular expression engine matching bug\", \"author\": \"rikonaka\", \"labels\": [], \"description\": \"I found that when using FancyRegex to match the following string, different output will appear\\r\\n\\r\\n```rust\\r\\nfn test_fancy_regex() {\\r\\n    let regex = FancyRegex::new(r\\\"^HTTP/1\\\\.[01] \\\\d\\\\d\\\\d (?:[^\\\\\\\\r\\\\\\\\n]*\\\\\\\\r\\\\\\\\n(?!\\\\\\\\r\\\\\\\\n))*?Server: Apache[/ ](\\\\d[-.\\\\w]+) ([^\\\\\\\\r\\\\\\\\n]+)\\\").unwrap();\\r\\n    let test_string = r\\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Tue, 07 Jan 2025 07:07:16 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n    let test_string = r\\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Wed, 18 Dec 2024 03:54:01 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n\\r\\n    let regex = FancyRegex::new(r\\\"^HTTP/1\\\\.[01] \\\\d\\\\d\\\\d .*Server: Apache[/ ](\\\\d[-.\\\\w]+) ([^\\\\\\\\r\\\\\\\\n]+)\\\").unwrap();\\r\\n    let test_string = r\\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Tue, 07 Jan 2025 07:07:16 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n    let test_string = r\\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Wed, 18 Dec 2024 03:54:01 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n}\\r\\n```\\r\\noutput\\r\\n\\r\\n![output](https://github.com/user-attachments/assets/1813cc7d-06ac-4251-b2d6-ec9ab669bac1)\\r\\n\\r\\nNormally, all four outputs should be True to comply with the rules.\", \"comments\": [{\"author\": \"BurntSushi\", \"body\": \"This doesn't look like a bug to me. It looks like you flubbed your escapes. For example, `r\\\"[\\\\\\\\r\\\\\\\\n]\\\"` is equivalent to `r\\\"[rn\\\\\\\\]\\\"`. What you seemingly want is `r\\\"[\\\\r\\\\n]\\\"`. I'd suggests [reviewing the docs for raw string literals](https://doc.rust-lang.org/reference/tokens.html#raw-string-literals).\\r\\n\\r\\nUpdated code where all four tests pass:\\r\\n\\r\\n```rust\\r\\nuse fancy_regex::Regex as FancyRegex;\\r\\n\\r\\nfn main() -> anyhow::Result<()> {\\r\\n    let regex = FancyRegex::new(r\\\"^HTTP/1\\\\.[01] \\\\d\\\\d\\\\d (?:[^\\\\r\\\\n]*\\\\r\\\\n(?!\\\\r\\\\n))*?Server: Apache[/ ](\\\\d[-.\\\\w]+) ([^\\\\r\\\\n]+)\\\").unwrap();\\r\\n    let test_string = \\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Tue, 07 Jan 2025 07:07:16 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n    let test_string = \\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Wed, 18 Dec 2024 03:54:01 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n\\r\\n    let regex = FancyRegex::new(\\r\\n        r\\\"^HTTP/1\\\\.[01] \\\\d\\\\d\\\\d (?s:.)*Server: Apache[/ ](\\\\d[-.\\\\w]+) ([^\\\\r\\\\n]+)\\\",\\r\\n    )\\r\\n    .unwrap();\\r\\n    let test_string = \\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Tue, 07 Jan 2025 07:07:16 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n    let test_string = \\\"HTTP/1.1 200 OK\\\\r\\\\nDate: Wed, 18 Dec 2024 03:54:01 GMT\\\\r\\\\nServer: Apache/2.4.62 (Debian)\\\\r\\\\n\\\";\\r\\n    let ret = regex.is_match(&test_string).unwrap();\\r\\n    println!(\\\"{}\\\", ret);\\r\\n\\r\\n    Ok(())\\r\\n}\\r\\n```\\r\\n\\r\\nThe steps I took were:\\r\\n\\r\\n* Keep the regex patterns in raw strings, but replace `\\\\\\\\r` and `\\\\\\\\n` with `\\\\r` and `\\\\n`.\\r\\n* Use regular string literals, not raw strings, for the haystack strings. With raw strings, things like `\\\\n` are _not_ processed as escape sequences and represented literally. But I'm guessing you want actual newline characters in your string. So use regular string literals.\\r\\n* In the second regex, `.` doesn't match through a `\\\\n` by default, but it does match through `\\\\\\\\n` (or `r\\\"\\\\n\\\"` in a raw string) since that isn't a newline character: it's a backslash followed by an ASCII `n`. So I changed your regex to use `(?s:.)` so that it matches through a `\\\\n`.\"}, {\"author\": \"rikonaka\", \"body\": \"Thank you very much for your prompt reply, through your explanation I have realized my misunderstanding, wish you a nice day. üòò\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_150", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"150\", \"title\": \"Execute regex on a text stream\", \"author\": \"xamgore\", \"labels\": [], \"description\": \"You have a bidirectional iterator over non-contiguous strings, you have a regex. How to match them?\\n\\n`regex-cursor` can do that, but it lacks backtracking.\\n\\n- https://github.com/rust-lang/regex/issues/425\\n- https://github.com/pascalkuthe/regex-cursor/issues/1\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_162", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"162\", \"title\": \"How similar to Oniguruma do we aim to be?\", \"author\": \"keith-hall\", \"labels\": [\"question\"], \"description\": \"Now that Oniguruma has been archived, there is a fair amount of interest in using fancy-regex as a replacement:\\n- https://github.com/trishume/syntect/issues/583\\n- https://github.com/sharkdp/bat/issues/3285\\n\\nI feel like it could be a good time to discuss the project's goals. My personal aim is for fancy-regex to be able to be used in a syntax highlighting context where Oniguruma has been traditionally used, and to get correct results with decent performance.\\nThe question is, do we want to take it a step further and have fancy-regex become a \\\"drop-in replacement\\\" (if that is even possible) for Oniguruma in other contexts as well (i.e. achieve test parity)?\\n\\nFor example, Oniguruma has some interesting behaviors, like the way the name of a capture group can be reused, which affects the way backreferences work as well as the match results available via the API.\\nDo we want to copy such functionality for compatibility or - if the primary motivation is for syntax highlighting - is it worth checking what is actually used in the wild (in various tmLanguage grammars etc) before deciding?\\n\\nIf we do decide to behave more like Oniguruma, I would like us to have more detailed documentation, to be more user friendly and perhaps set us apart a little. Maybe this example is kinda obvious but I had a look at inlining non-recursive subroutine calls, to get a performance boost by having the inlined pattern go straight through the regex crate if none of the expressions are hard / require backtracking, and I discovered that calling a subroutine also populates the capture group - which put a spanner in the works...\\n\\nWhat do others think? üôÇ\", \"comments\": [{\"author\": \"si14\", \"body\": \"My two cents: there's a related discussion here https://github.com/getzola/zola/issues/2758\\n\\nIn particular, [oniguruma-to-es](https://github.com/slevithan/oniguruma-to-es) can be interesting in two respects:\\n* as a guideline to which subset of Oniguruma features is actually used in real world tmLanguage grammars\\n* as a demonstration of \\\"transpilation\\\" of Oniguruma to ES regexes\\n\\nOne way forward would be to use ES as a goal and provide a `oniguruma-to-es`-esque compatibility layer. Note that `oniguruma-to-es` had to add a [runtime shim](https://github.com/slevithan/oniguruma-to-es/blob/main/src/subclass.js) on top of standard ES regexes to cover almost all tmLanguage they test on.\"}, {\"author\": \"robinst\", \"body\": \"> My personal aim is for fancy-regex to be able to be used in a syntax highlighting context where Oniguruma has been traditionally used, and to get correct results with decent performance.\\n\\nThat sounds like a good goal.\\n\\n> do we want to take it a step further\\n\\nI'm happy to support but I personally won't be able to contribute towards this except for reviews. Btw I appreciate how you've stepped up and helped maintain recently @keith-hall!\\n\\n> is it worth checking what is actually used in the wild (in various tmLanguage grammars etc) before deciding?\\n\\nYes. I'm not sure we need to copy every \\\"esoteric\\\" feature unless it's actually used. From the linked zola thread it sounds like the main thing that is missing is subexp calls (`\\\\g`) and a few escapes?\\n\\n> I would like us to have more detailed documentation, to be more user friendly and perhaps set us apart a little\\n\\nThat sounds nice to have even without the Oniguruma goal. More documentation, more examples, yes please :).\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_163", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"163\", \"title\": \"Issue with case-insensitive regex\", \"author\": \"angelorendina\", \"labels\": [\"bug\"], \"description\": \"I was trying to use the regex defined here [here](https://colinhacks.com/essays/reasonable-email-regex) to validate emails. The regex is explained in the reference, and it seems to work natively on the browser as is.\\nThe issue I am facing is that the same regex (wrapped in case-insensitive fancy-regex) fails if there are capitalised letters, see repro below.\\n\\n```rust\\nfn is_valid_email(email: &str) -> bool {\\n    let regex = fancy_regex::RegexBuilder::new(\\n        r\\\"^(?!\\\\.)(?!.*\\\\.\\\\.)([a-z0-9_'+\\\\-\\\\.]*)[a-z0-9_'+\\\\-]@([a-z0-9][a-z0-9\\\\-]*\\\\.)+[a-z]{2,}$\\\",\\n    )\\n    .case_insensitive(true)\\n    .build()\\n    .unwrap();\\n\\n    regex.is_match(email).unwrap()\\n}\\n\\n#[test]\\nfn case_insensitive_email() {\\n    let is_valid = is_valid_email(\\\"VALID@domain.com\\\");\\n    assert!(is_valid);\\n}\\n```\\n\\nThe test assertion fails (no panics), even though I am expecting it to pass (and the same regex with the same input are fine on my browser JS engine). Using `valid@domain.com` is perfectly accepted instead.\", \"comments\": [{\"author\": \"Viorel\", \"body\": \"To work around the problem, try to start the regular expression with `(?i)`.\"}, {\"author\": \"keith-hall\", \"body\": \"Thanks for reporting, I can confirm that this is a bug. I prepared a test case (for https://github.com/fancy-regex/fancy-regex/blob/main/tests/regex_options.rs) to prove it, and it currently fails:\\n```rust\\n#[test]\\nfn check_casing_insensitive_option_hard() {\\n    let builder = RegexBuilder::new(r\\\"[a-z](?<=[^f])\\\")\\n        .case_insensitive(true)\\n        .build();\\n\\n    match builder {\\n        Ok(regex) => {\\n            assert!(regex.is_match(r\\\"J\\\").unwrap_or_default());\\n            assert!(!regex.is_match(r\\\"F\\\").unwrap_or_default());\\n            assert!(regex.is_match(r\\\"j\\\").unwrap_or_default());\\n        }\\n        _ => panic!(\\\"builder should be able to compile with casing options\\\"),\\n    }\\n}\\n```\\n\\nThe problem arises because `Compiler` always creates a new instance of `RegexOptions`:\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/compile.rs#L105\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/compile.rs#L527-L528\\n\\nwhich therefore loses the case insensitive setting.\\nI had a quick look at fixing it by passing the `RegexOptions` as an argument to the `compile` method, but it gets complicated because `compile` is `pub` so that the `toy`  example can use it, but `RegexOptions` isn't.\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/lib.rs#L535\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/lib.rs#L1805\\n\\nTo be honest, I don't really like the way `fancy-regex` uses `SyntaxConfig`, because it means the parser is out of sync with what gets compiled as delegates. I had the idea that it would be nice to be able to set some starting flags instead. But that is also non-trivial because flags are currently non-pub also and not part of a convenient encapsulation...\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/lib.rs#L537\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/parse.rs#L100-L106\\nhttps://github.com/fancy-regex/fancy-regex/blob/main/src/parse.rs#L35-L40\"}, {\"author\": \"keith-hall\", \"body\": \"FYI, there is a PR open to fix this: https://github.com/fancy-regex/fancy-regex/pull/165\"}, {\"author\": \"robinst\", \"body\": \"Fixed in 0.15.0 üéâ: https://github.com/fancy-regex/fancy-regex/blob/main/CHANGELOG.md#0150---2025-07-06\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_168", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"168\", \"title\": \"`derivative` is unmaintained\", \"author\": \"jalil-salame\", \"labels\": [], \"description\": \"Derivative seems to be unmaintained: https://github.com/mcarton/rust-derivative/issues/117\\n\\nYou use `derivative` here: https://github.com/fancy-regex/fancy-regex/blob/39bee7726bcc2e9247f1ca7a92667d33159a6db7/src/vm.rs#L190-L200\\n\\nMaybe extracting this to a struct with a manual `Debug` impl would be better?:\\n\\n```rust\\n#[derive(Clone, Debug)]\\npub enum Insn {\\n    // ...\\n    /// Delegate matching to the regex crate\\n    Delegate(Delegate),\\n    // ...\\n}\\n\\n#[derive(Clone)]\\npub struct Delegate {\\n    /// The regex\\n    inner: Regex,\\n    /// The regex pattern as a string\\n    pattern: String,\\n    /// The first group number that this regex captures (if it contains groups)\\n    start_group: usize,\\n    /// The last group number\\n    end_group: usize,\\n}\\n\\nimpl std::fmt::Debug for Delegate {\\n    // TODO: implement\\n}\\n```\\n\\nThis way you can outright drop the dependency on `derivative`, I can implement this if you'd like\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"That sounds like a good solution to me, yes please - thanks üôÇ\"}, {\"author\": \"reubeno\", \"body\": \"Thanks for resolving this issue! We noticed this too when `cargo deny` started flagging a security advisory against `derivative` when we upgraded to the most recent release of `fancy-regex`.\\n\\nI'm looking forward to when this change will make its way into the next release of `fancy-regex`.\"}, {\"author\": \"jqnatividad\", \"body\": \"Speaking of the next release @keith-hall , is there an ETA?\"}, {\"author\": \"keith-hall\", \"body\": \"I'm hoping before the end of the coming weekend, if not sooner. Out of interest, has anyone tried latest `main` branch? üôÇ \"}, {\"author\": \"keith-hall\", \"body\": \"released in v[0.16.0](https://github.com/fancy-regex/fancy-regex/releases/tag/0.16.0)\"}, {\"author\": \"reubeno\", \"body\": \"Thanks so much for the quick turnaround! I'll upgrade shortly üôÇ\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_173", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"173\", \"title\": \"‚ÄúIndex out of bounds‚Äù caused by incorrect backreferences\", \"author\": \"Viorel\", \"labels\": [\"bug\"], \"description\": \"Using **fancy-regex 0.16.0**, the next code detects an invalid backreference:\\n\\n```rust\\nuse fancy_regex::Regex;\\n\\nfn main()  \\n{\\n    let re = Regex::new(r\\\"a\\\\1\\\").unwrap();\\n    let result : bool = re.is_match(\\\"aa\\\").unwrap();\\n\\n    println!(\\\"{:?}\\\", result);\\n}\\n```\\n\\nIt throws the expected error: _called \\\\`Result::unwrap()\\\\` on an \\\\`Err\\\\` value: ParseError(2, InvalidBackref)_.\\n\\nHowever, if the pattern is changed:\\n\\n```rust\\nlet re = Regex::new(r\\\"aa\\\\1\\\").unwrap();\\nlet result : bool = re.is_match(\\\"aa\\\").unwrap();\\n```\\n\\nthen it raises a different error: _thread 'main' panicked at C:\\\\\\\\Users\\\\\\\\...\\\\\\\\.cargo\\\\\\\\registry\\\\\\\\src\\\\\\\\index.crates.io-1949cf8c6b5b557f\\\\\\\\fancy-regex-0.16.0\\\\\\\\src\\\\\\\\vm.rs:348:19: index out of bounds: the len is 2 but the index is 2_.\\n\\nI think that it should be generating the same _InvalidBackref_ error instead of ‚Äúindex out of bounds‚Äù.\\n\\nIn addition, if the code is changed to:\\n\\n```rust\\nlet re = Regex::new(r\\\"aa\\\\1\\\").unwrap();\\nlet result : bool = re.is_match(\\\"ab\\\").unwrap();\\n```\\n\\nthen it does not report any problem, even though the backreference is still invalid. (The program prints _false_).\\n\\nThe program gives the expected _InvalidBackref_ error in all the above examples in case of previous **fancy-regex 0.15.0**, or if `\\\\2` is used instead of `\\\\1`.\\n\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Thanks for reporting. I have submitted a PR to fix this here: https://github.com/fancy-regex/fancy-regex/pull/174\"}, {\"author\": \"keith-hall\", \"body\": \"The fix has now been released in v[0.16.1](https://github.com/fancy-regex/fancy-regex/releases/tag/0.16.1) üôÇ \"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_175", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"175\", \"title\": \"Optimization for \\\\K at root level\", \"author\": \"keith-hall\", \"labels\": [\"good first issue\", \"optimization/performance\"], \"description\": \"We recently introduced an optimization step which runs after parsing but before analyzing the regex pattern: https://github.com/fancy-regex/fancy-regex/pull/171\\n\\nIt works by rewriting an expression with a trailing positive lookahead into the same expression semantically, by using an explicit capture group 0 and removing the lookahead itself, just keeping the contents.\\n\\nWe can do something similar for `\\\\K` at root level i.e. convert `\\\\w+:\\\\s*\\\"\\\\K[^\\\"]*` into  `\\\\w+:\\\\s*\\\"([^\\\"]*)`. If the `tree.expr` is a `Concat`, iterate through the children to see if one of those children is a `KeepOut`. If it is, put the remainder of the children (i.e. after/following the `\\\\K`) into a capture group which will be group 0, and replace the `KeepOut` `Expr` with that capture group. Then, it will automatically work such that if the rest of the expression is easy, it will delegate the whole thing to the regex crate without going through the VM.\\n\\nBonus points if it will interact with trailing lookaheads, to apply both optimizations together with only creating one new capture group...\\ni.e. turn `\\\\w+:\\\\s*\\\"\\\\K[^\\\"]*(?=\\\")` into  `\\\\w+:\\\\s*\\\"([^\\\"]*)\\\"`. Otherwise, we may be able to only one of those optimizations at a time, because we can't have 2 explicit capture group 0s... (or can we? perhaps try it...)\\n\\nThe same criteria applies as for the trailing lookahead rewriting - we can only do it if the entire expression isn't recursive otherwise it will change the semantics\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_176", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"176\", \"title\": \"interactive playground\", \"author\": \"keith-hall\", \"labels\": [\"enhancement\", \"playground\"], \"description\": \"It would be very convenient to experiment with fancy-regex if we would have a playground for it, which could run in the browser by compiling fancy-regex into WASM. This could be more interactive than the command line based `toy` example we have.\\n\\n(Eventual) desired features:\\n- allow user to enter multiline input text\\n- allow user to enter multiline regex\\n- allow user to set which flags should be active (or just let them put the flags in the expression like `(?x)`?)\\n- show/highlight matches\\n- show/highlight capture groups\\n- show parse errors, compile errors etc\\n- it would update in real time as the haystack or the regex changes etc. (maybe with a debounce?)\\n- option to show the parse tree\\n- option to show the analyzer output\\n- publish to GitHub Pages\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Work on this has started in https://github.com/fancy-regex/fancy-regex/pull/181\"}, {\"author\": \"keith-hall\", \"body\": \"The main work on this is complete. What is left:\\n- [x] üêõ fix match highlighting being in the wrong place after non-ascii text (like emojis): addressed by https://github.com/fancy-regex/fancy-regex/pull/190\\n-  [ ] üå≤ show the parse tree and analysis as a tree view instead of debug format text\\n   - show hard nodes in a different color\\n   - ideally link the two trees together, but this may get trickier once optimizations are applied because the parse tree is no longer in sync with the analysis info nodes\\n- [ ] üñåÔ∏è other UI/styling improvements as we see fit\\n- [ ] üì¶ maybe replace the version in the footer with a git commit hash when the playground is deployed from a commit which isn't tagged with a release version\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_177", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"177\", \"title\": \"Update the parser to track multiple same-named groups\", \"author\": \"keith-hall\", \"labels\": [\"enhancement\", \"good first issue\"], \"description\": \"We will need to update the parser to track when multiple groups are defined with the same name. This is so the caller can decide how to react when the same name is used to declare multiple groups. We need this to be able to match Oniguruma behavior:\\n\\n- [with backrefs referring to a named group with more than one declaration](https://github.com/kkos/oniguruma/blob/master/doc/RE#L420-L422)\\n  > When backreferencing with a name that is assigned to more than one group, the last group with the name is checked first, if not matched then the previous one with the name, and so on, until there is a match.\\n- with subroutine calls referring to a named group with more than one declaration ([to be a compile error](https://github.com/kkos/oniguruma/blob/master/doc/RE#L479-L480))\\n  > Calls with a name that is assigned to more than one group are not allowed.\\n\\nFor this issue we can just handle the changes to the parser, and resolve it to a single numbered group when compiling, to match the current behavior. This will keep the changes smaller - we can then work on updating the backref behavior to more closely match Oniguruma afterwards.\\n\\nPossible approaches:\\n- change the type of the [`named_groups` on the Parser](https://github.com/fancy-regex/fancy-regex/blob/1710dd0ab9d87ed25d8fd3f19c08e6b6f76f54b7/src/parse.rs#L37-L46) (less invasive)\\n- or emit a separate `Expr` variant for named groups (more invasive)\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_178", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"178\", \"title\": \"Return a compile error for left recursive subroutine calls\", \"author\": \"keith-hall\", \"labels\": [\"enhancement\"], \"description\": \"Let's create a new `CompileError` variant for when a left recursive subroutine call is detected, and update the analyzer to emit it when applicable.\\nhttps://github.com/kkos/oniguruma/blob/master/doc/RE#L474-L477\", \"comments\": []}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_180", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"180\", \"title\": \"`\\\\>` no longer matches a literal `>`, unlike Oniguruma\", \"author\": \"CosmicHorrorDev\", \"labels\": [], \"description\": \"It looks like starting with `fancy-regex` version `0.13.0` the regex string `\\\\>` (an incorrectly escaped `>`) no longer matches a literal `>`. This behavior appears to deviate from Oniguruma\\n\\n## Demo\\n\\n```toml\\n[package]\\nname = \\\"fancy-bug\\\"\\nversion = \\\"0.1.0\\\"\\nedition = \\\"2024\\\"\\n\\n[dependencies]\\nfancy-regex-12 = { package = \\\"fancy-regex\\\", version = \\\"0.12.0\\\" }\\nfancy-regex-13 = { package = \\\"fancy-regex\\\", version = \\\"0.13.0\\\" }\\nonig = \\\"6.5.1\\\"\\n```\\n\\n```rust\\nfn main() {\\n    try_main().unwrap();\\n}\\n\\nfn try_main() -> Option<()> {\\n    let regex_str = r\\\"\\\\>\\\";\\n    let haystack = \\\" >\\\";\\n\\n    // fancy-regex 0.12.0\\n    let fancy_regex_12 = fancy_regex_12::Regex::new(regex_str).ok()?;\\n    let fancy_pos_12 = fancy_regex_12.captures(haystack).ok()??.get(0)?.range();\\n\\n    // fancy-regex 0.13.0\\n    let fancy_regex_13 = fancy_regex_13::Regex::new(regex_str).ok()?;\\n    // no capture :/\\n    assert!(fancy_regex_13.captures(haystack).ok()?.is_none());\\n\\n    // onig latest\\n    let onig_regex = onig::Regex::new(regex_str).ok()?;\\n    let onig_pos = onig_regex.captures(haystack)?.pos(0)?;\\n\\n    println!(\\\"fancy-regex 0.12.0: {fancy_pos_12:?}\\\\nonig: {onig_pos:?}\\\");\\n\\n    Some(())\\n}\\n```\\n\\n```console\\n$ cargo r\\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.03s\\n     Running `target/debug/fancy-bug`\\nfancy-regex 0.12.0: 1..2\\nonig: (1, 2)\\n```\\n\\n## Context\\n\\nThis is coming from this `syntect` PR where updating `fancy-regex` led to some issues due to several syntax definitions containing regexes that incorrectly escape `<` and `>`\\n\\n- trishume/syntect#596\\n\\nand a relevant comment from @keith-hall as well\\n\\n- https://github.com/trishume/syntect/pull/596#issuecomment-3182226397\\n\\nAs mentioned in that thread I'm planning on trying to tackle this issue if I can manage it üòº \", \"comments\": [{\"author\": \"Viorel\", \"body\": \"I think that it corresponds to Oniguruma, if it is configured to use the _ONIG_SYNTAX_GREP_ or _ONIG_SYNTAX_GNU_REGEX_ syntax.\\n\\nA series of engines (including **regex** and **regex_lite** in Rust) uses `\\\\<` and `\\\\>` for ‚Äústart of word‚Äù and ‚Äúend of word‚Äù.\"}, {\"author\": \"keith-hall\", \"body\": \"> I think that it corresponds to Oniguruma, if it is configured to use the _ONIG_SYNTAX_GREP_ or _ONIG_SYNTAX_GNU_REGEX_ syntax.\\n> \\n> A series of engines (including **regex** and **regex_lite** in Rust) uses `\\\\<` and `\\\\>` for ‚Äústart of word‚Äù and ‚Äúend of word‚Äù.\\n\\nThis is why I suggested keeping this behind a flag in the `RegexBuilder`, so syntax highlighting/Oniguruma-replacement use-cases can have it treated as a literal, and regex-crate with fancy features use-cases can have the word boundary behavior.\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_184", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"184\", \"title\": \"Broken string conversion\", \"author\": \"thomasschafer\", \"labels\": [], \"description\": \"Hi, it looks like string conversion broke in the upgrade from 15.0 to 16.0:\\n\\n```rust\\nuse fancy_regex::Regex as FancyRegex;\\n\\n#[test]\\nfn test_lookahead() {\\n    let re_1 = FancyRegex::new(r\\\"\\\\w+(?=\\\\.\\\\w+$)\\\").unwrap();\\n    let res = re_1.replace_all(\\\"document.pdf\\\", \\\"report\\\");\\n    assert_eq!(res, \\\"report.pdf\\\", \\\"Failed 1st time\\\");\\n\\n    let re_2 = FancyRegex::new(re_1.as_str()).unwrap();\\n    let res = re_2.replace_all(\\\"document.pdf\\\", \\\"report\\\");\\n    assert_eq!(res, \\\"report.pdf\\\", \\\"Failed 2nd time\\\");\\n}\\n```\\n\\nResults:\\n\\n```sh\\nassertion `left == right` failed: Failed 2nd time\\n  left: \\\"report\\\"\\n right: \\\"report.pdf\\\"\\n```\\n\\nI'd expect that converting the regex to an `&str` and back again shouldn't change the result of `replace_all`, but it looks like it does.\", \"comments\": [{\"author\": \"keith-hall\", \"body\": \"Thanks for reporting. The reason why this happens is due to an optimization which takes the trailing positive lookahead and rewrites the expression to use an explicit capture group 0 so the entire pattern can be executed by the regex crate without needing any \\\"fancy\\\" features. I confess that I overlooked that `as_str` is explicitly documented as returning the original input string. I have proposed a fix in https://github.com/fancy-regex/fancy-regex/pull/185 which would allow me to still debug what regex pattern is actually being compiled under the hood but keep the `as_str`invariant.\"}, {\"author\": \"keith-hall\", \"body\": \"As a side note, can I ask what you use `as_str` for please? I'm curious if your use case would be better served by having Regex be serializable/deserializable?\"}, {\"author\": \"thomasschafer\", \"body\": \"Sounds great, thank you for looking into it so quickly!\\n\\n> As a side note, can I ask what you use as_str for please? I'm curious if your use case would be better served by having Regex be serializable/deserializable?\\n\\nI'm currently using `as_str` as I have a function that takes a compiled regex and optionally transforms it, adding `(?i)` to make it case insensitive, something like the following:\\n\\n```rust\\nuse fancy_regex::Regex;\\n\\nfn transform(re: Regex) -> Regex {\\n    if condition {\\n        let re_str = re.as_str();\\n        let transformed = format!(\\\"(?i){re_str}\\\");\\n        Regex::new(&transformed).unwrap()\\n    } else {\\n        re\\n    }\\n}\\n```\\n\\nI could refactor to avoid this process of compiling then converting to a string and compiling again, but it was the easiest implementation at the time. I'm not sure that having it be serializable/deserializable would help here but if I'm missing something let me know!\"}, {\"author\": \"keith-hall\", \"body\": \"Thanks for the explanation - indeed serialization probably won't help here. I mainly wanted to see if we can avoid all the double work of re-parsing, analyzing, compiling the pattern etc. But changing the flags is probably one of those cases that needs to do most of the work again anyway.\\nYou could avoid the string manipulation by using the `RegexBuilder` and it's `case_insensitive` method btw, but if you are happy with your current approach there is no need to change it. There's a small edge case whereby the pattern might begin with `(?-i)` or something for example, and then these approaches wouldn't work - that's where the parser being public could help more...\"}, {\"author\": \"thomasschafer\", \"body\": \"Ah I hadn‚Äôt thought of using the builder, I‚Äôll experiment with that! I appreciate the pointers and context\"}]}"}]}}
{"custom_id": "fancy-regex_fancy-regex_issue_197", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **fancy-regex** regex engine, developed by **fancy-regex**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the fancy-regex regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a ‚ÄúReal Bug‚Äù**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., fancy-regex vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING ‚Äì found via fuzzing tools\n* STATIC_ANALYSIS ‚Äì found via automated static analysis\n* MANUAL_REVIEW ‚Äì found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING ‚Äì found by comparing results with other engines\n* OTHER ‚Äì explicitly stated custom method\n* `null` ‚Äì if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2‚Äì6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification‚Äîonly extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"197\", \"title\": \"Optimize \\\\G when it is the first instruction\", \"author\": \"keith-hall\", \"labels\": [\"optimization/performance\"], \"description\": \"When `\\\\G` appears at the start of a pattern and fails, the VM continues checking every other position in the haystack despite `\\\\G` never being able to match after the first failure. This causes O(n) behavior where O(1) is possible.\\n\\nOne possible fix for this is fairly simple, determine when `\\\\G` is the first `Expr` in the tree, pass that as a boolean down into the `ContinueFromPreviousMatchEnd` instruction and [instead of `break 'fail`](https://github.com/fancy-regex/fancy-regex/blob/f48e5bdbb26e1548ae3a475fb433140be437f1ed/src/vm.rs#L830-L834) it could do an early `return Ok(None)`\\nI guess it doesn't have to be the exact first Expr in the tree/pattern, as long as there are only const size min size 0 `Expr`s/`Info`s preceding it.\\n(N.B. worth remembering that a `|`  at the same level would render this optimization not possible)\\n\", \"comments\": []}"}]}}
