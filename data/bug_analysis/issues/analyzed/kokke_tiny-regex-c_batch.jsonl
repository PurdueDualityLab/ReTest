{"custom_id": "kokke_tiny-regex-c_issue_2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"2\", \"title\": \"Feature Requests and Minor Code Comments\", \"author\": \"mattharrigan\", \"labels\": [], \"description\": \"Hello.  First thank you for this library.  It has been very helpful.  Two small comments/questions on the code.  Note I am still learning C.\\r\\n\\r\\nFirst [here](https://github.com/kokke/tiny-regex-c/blob/master/re.c#L107) I think ccl_bufidx could be initialized to 1, otherwise the first slot in the array is unused.  I might be missing something though.\\r\\n\\r\\nSecond, I don't understand why there is a union in the struct regex_t.  I think with padding it doesn't actually save any space for most architectures.  However it might be possible to keep an index for the array instead of the pointer to the position in the array, which could be a small data type, possible even just a char.\\r\\n\\r\\nFinally two features would help me, and perhaps many others also.  First would be case insensitive matching.  The second would be to have dynamically allocated patterns, which would allow more than one pattern to be used in a program.  I realize either of those may not be in keeping with \\\"tiny\\\", so they may not be appropriate here.\\r\\n\\r\\nAgain thank you very much for this useful code.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @mattharrigan and thank you for taking an interest in this project :)\\r\\n\\r\\nFirst I'm sorry I've been so slow to respond. Your issue slipped my mind for quite some time...\\r\\n\\r\\nI don't actually remember my reasoning for initializing the index to 1. Maybe that's also why I never got back to you in the first place.\\r\\n\\r\\nThe reason for the union is to be able to safely use the same piece of memory as both a char and a pointer. [Type punning](https://en.wikipedia.org/wiki/Type_punning) can invoke undefined behavior which leads to crazy bugs :)\\r\\n\\r\\nPlease check out #7 for dynamic allocation and a much more feature-packed fork of this project.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"3\", \"title\": \"Enable use of multiple patterns at the same time\", \"author\": \"mahdix\", \"labels\": [], \"description\": \"Compiled patterns are kept in a static variable which means they will be overwritten as soon as another pattern is compiled.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @mahdix - thanks for taking an interest :)\\r\\n\\r\\nThere is [another issue detailing this flaw](https://github.com/kokke/tiny-regex-c/issues/2) - I agree with you both that the compiled pattern should be passed as a pointer to the compile function.\\r\\n\\r\\nI will see if I can find the time to implement this feature. \\r\\nYou are also welcome to suggest a change via a Pull Request :)\\r\\n\\r\\nThank you for your feedback\"}, {\"author\": \"ghost\", \"body\": \"Hi, there is a fork of this library available which I ported to work in the kernel of the FreeBSD. https://github.com/komdivkote/tiny-regex-c\\r\\nThe function re_compile(const char* pattern, uint32_t * o_reg_cnt) returns a pointer to an **array** of a new instance of **struct re_regex * re_compiled**  allocated in heap because the kernel has small stack. It uses realloc approach when it runs out of the free REGEXP_OBJECTS. This approach  decreases the performance comparing with the initial approach because malloc and realloc are both \\\"expensive\\\" operations.\\r\\nThe logic of some routines was changed a bit and there were introduced macroses (_like FOR_EACH for automation of enums and its names creation during compilation for the different CPU architectures i.e Harvard/Von Neumann_)  to the code because the library works in both kernel/userland, but if this is a problem you can remove the 'kernel' code which is \\\"#ifdef _KERNEL\\\".\\r\\n\\r\\nAlso there some tuning available in the re.h:\\r\\n` \\r\\n#define RE_REGEX_INSTANCE_REALLOCATE\\tYES\\t//YES - reallocate on overuse, NO - exit  \\r\\n\\r\\n#define RE_TRUNC_ARRAY_IF_POSSIBLE\\t\\tYES\\t//YES - truncate array to reduce size, NO - do not  \\r\\n\\r\\n#define RE_CHAR_CLASS_LENGTH\\t\\t\\t20\\t//per struct regex_t instance  \\r\\n\\r\\n#define MIN_REGEXP_OBJECTS\\t\\t\\t\\t30\\t//min number of regex symbols in expression.\\r\\n  \\r\\n#define RE_BUILDWITH_DEBUG\\tYES\\t//compile with print and trace functions  \\r\\n`\\r\\n\\r\\nI will try to  form a pull request without kernel code.\"}, {\"author\": \"kokke\", \"body\": \"Hi @komdivkote - wow you've really done something with the code :D A pull request would be awesome :)\\r\\n\\r\\nI really find it interesting to see how other people use my code.\\r\\nI'm in the embedded business for a living, which is what inspires me to keep the resource utilization frugal. Kernel code has some of the same flavor, so I get your motivation for a small regex-project.\\r\\n\\r\\n\\r\\n\\r\\nAnecdote:\\r\\nI haven't run FreeBSD since 8.0-RELEASE, but I've always been fond of how the BSDs work and organize things. I also like NetBSD for its minimalism.\"}, {\"author\": \"Nable80\", \"body\": \"Oh, it looks like people asked for this feature (and provided some kind of implementations) multiple times in the past.\\r\\nHere's one of the latest attempts: https://github.com/kokke/tiny-regex-c/pull/45\\r\\n\\r\\n@kokke, what do you think about this issue? IMHO there should be some final decision: either merge one of implementations as an optional feature or mark it as \\\"wontfix\\\" and clearly mention in documentation that it doesn't fit well here (and mention some featured alternatives for those who need this feature too much). What do you think?\\r\\n\\r\\nSome kind of perfectionism makes me worry about old stale issues, especially in small well-written projects where it looks definitely possible to achieve and maintain \\\"zero known/open issues\\\" state.\"}, {\"author\": \"qgymib\", \"body\": \"Hi,\\r\\n\\r\\nThere might be a simple solution for this (without dynamic memory allocation to keep original design):\\r\\n\\r\\n1. define `struct regex` as following:\\r\\n\\r\\n```\\r\\nstruct regex\\r\\n{\\r\\n    size_t size;\\r\\n    regex2_t data[];\\r\\n};\\r\\n```\\r\\n\\r\\nWhere `regex2_t` is the original regex structure in your source code.\\r\\n\\r\\n\\r\\n2. add a new interface:\\r\\n\\r\\n```\\r\\nre_t re_compile2(const char* pattern, void* buffer, size_t size);\\r\\n```\\r\\n\\r\\nThis function initialize `struct regex` on `buffer`, just looks like:\\r\\n\\r\\n```\\r\\nre_t re_compile2(const char* pattern, void* buffer, size_t size)\\r\\n{\\r\\n    if (/* Some code to check if buffer size is large enough */)\\r\\n    {\\r\\n        return NULL; /* buffer is too small */\\r\\n    }\\r\\n\\r\\n    struct regex* ret = (struct regex*)buffer;\\r\\n    ret->size = size / sizeof(struct regex2_t);\\r\\n\\r\\n    /* Now compile patterm into ret->data just like #re_compile() */\\r\\n\\r\\n    return ret;\\r\\n}\\r\\n```\\r\\n\\r\\n3. No more step.\\r\\n\\r\\nIf user want to get compile failure reason, may be another parameter `err` can be added, like:\\r\\n\\r\\n```\\r\\nre_t re_compile2(const char* pattern, void* buffer, size_t size, int* err);\\r\\n```\\r\\n\"}, {\"author\": \"marler8997\", \"body\": \"Here's my attempt: https://github.com/kokke/tiny-regex-c/pull/58\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"4\", \"title\": \"Needs #ifdef __cplusplus\", \"author\": \"blitz-research\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nNice little library!\\r\\n\\r\\nTo make it usable with c++, you need to add this:\\r\\n\\r\\n```\\r\\n#ifdef _cplusplus\\r\\nextern \\\"C\\\"{\\r\\n#endif\\r\\n```\\r\\n...before the definitions in the header file, and this...\\r\\n\\r\\n```\\r\\n#ifdef _cplusplus\\r\\n}\\r\\n#endif\\r\\n```\\r\\n\\r\\n...after.\\r\\n\\r\\nOtherwise, c++ will assume symbols like re_match etc are c++ symbols and you'll get link errors. More info here:\\r\\n\\r\\nhttps://stackoverflow.com/questions/3789340/combining-c-and-c-how-does-ifdef-cplusplus-work\\r\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @blitz-research , thanks for your kind words :)\\r\\n\\r\\nOh, I haven't mixed C and C++ in a few years, so I hadn't been aware of that issue - thanks for mentioning it :)\\r\\n\\r\\nYeah I would have to do that to avoid trouble with the name mangling right? \\r\\nOr could I require the user to know that the library is written in C, and then do one of two:\\r\\n\\r\\n1) either put it in a C++ header with the `extern C { ... }` tag wrapped around the contents of the C-header\\r\\n2) or put the `extern`-stuff before `#include`'ing the C-header\\r\\n\\r\\nWhat do you think? Would any of those options work for C++? I'm online from my phone right now, so no easy way to test it at the moment..\"}, {\"author\": \"blitz-research\", \"body\": \"Just add the #ifdefs to the existing re.h file. C compilers will ignore them because __cplusplus wont be defined, and c++ compilers will know not to mangle the names because of the extern\\\"C\\\".\\r\\n\\r\\nHere's my re.h which builds fine with my c++ code. Would've done a pull request except I suck at git.\\r\\n\\r\\n```\\r\\n/*\\r\\n *\\r\\n * Mini regex-module inspired by Rob Pike's regex code described in:\\r\\n *\\r\\n * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html\\r\\n *\\r\\n *\\r\\n *\\r\\n * Supports:\\r\\n * ---------\\r\\n *   '.'        Dot, matches any character\\r\\n *   '^'        Start anchor, matches beginning of string\\r\\n *   '$'        End anchor, matches end of string\\r\\n *   '*'        Asterisk, match zero or more (greedy)\\r\\n *   '+'        Plus, match one or more (greedy)\\r\\n *   '?'        Question, match zero or one (non-greedy)\\r\\n *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}\\r\\n *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!\\r\\n *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }\\r\\n *   '\\\\s'       Whitespace, \\\\t \\\\f \\\\r \\\\n \\\\v and spaces\\r\\n *   '\\\\S'       Non-whitespace\\r\\n *   '\\\\w'       Alphanumeric, [a-zA-Z0-9_]\\r\\n *   '\\\\W'       Non-alphanumeric\\r\\n *   '\\\\d'       Digits, [0-9]\\r\\n *   '\\\\D'       Non-digits\\r\\n *\\r\\n *\\r\\n */\\r\\n\\r\\n#ifdef __cplusplus\\r\\nextern \\\"C\\\"{\\r\\n#endif\\r\\n\\r\\n/* Typedef'd pointer to get abstract datatype. */\\r\\ntypedef struct regex_t* re_t;\\r\\n\\r\\n\\r\\n/* Compile regex string pattern to a regex_t-array. */\\r\\nre_t re_compile(const char* pattern);\\r\\n\\r\\n\\r\\n/* Find matches of the compiled pattern inside text. */\\r\\nint  re_matchp(re_t pattern, const char* text);\\r\\n\\r\\n\\r\\n/* Find matches of the txt pattern inside text (will compile automatically first). */\\r\\nint  re_match(const char* pattern, const char* text);\\r\\n\\r\\n#ifdef __cplusplus\\r\\n}\\r\\n#endif\\r\\n```\\r\\n\"}, {\"author\": \"blitz-research\", \"body\": \"...might also want to add an include guard, but it's such a small file it probably wouldn't be any faster!\"}, {\"author\": \"kokke\", \"body\": \"Yeah that is just the best solution :)\\r\\n\\r\\nI've added the `#ifdef`-guard in the header - try pulling\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_10", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"10\", \"title\": \"Bug in matchpattern\", \"author\": \"Cthutu\", \"labels\": [], \"description\": \"In the matchpattern function you pass `&pattern[2]` to matchStar and matchPlus.  This should be `&pattern[1]`.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @Cthutu and thanks for reading my code :)\\r\\n\\r\\nI don't think you are correct on this point, since if I apply this change, the test suite starts failing catastrophically.\\r\\n\\r\\nHave you accounted any errors since you believe this to be a bug?\\r\\n\"}, {\"author\": \"Cthutu\", \"body\": \"Sorry - I think you're right.  I expected \\\"\\\\\\\\S*\\\" to fail on \\\"\\\\t \\\\n\\\", but of course '*' matches to 0 occurrences :)  Sorry for wasting your time.\"}, {\"author\": \"Cthutu\", \"body\": \"I've corporated your code into my C libraries and add hexadecimal matching with \\\\x and \\\\X.  Thanks for writing this.  It's given me a head start.  I will also fix the static local variables using my dynamic array stuff. And I will probably add a feature to give me the length of the match.\"}, {\"author\": \"kokke\", \"body\": \"No problem, always happy to hear about uses of the code.\\r\\nI'm looking forward to reading your implementation :)\\r\\n\\r\\nSeason's greetings \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_11", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"11\", \"title\": \"Can you support \\\"Match - Search\\\" feature?\", \"author\": \"4kzeng\", \"labels\": [], \"description\": \"example:  \\r\\n    src text:   hello,  ac97!\\r\\n    char* p  = re_search(src,  \\\"^.+,/s?+ac(/d/d)\\\");\\r\\n   if( p != NULL )\\r\\n       printf(\\\"Number is %c%c\\\\n\\\", *p, *(p+1));\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @4kzeng and thank you for taking an interest in this project :)\\r\\n\\r\\nUnfortunately the current design does not support capturing groups at the moment, so what you are asking is currently not supported.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_12", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"12\", \"title\": \"Can I set the number of characters for numbers?\", \"author\": \"Avlaak\", \"labels\": [\"bug\", \"help wanted\"], \"description\": \"Can i set the number of characters for numbers (from 1 to 2), for example for this format \\\"00:00:00\\\"? \\r\\nThe following pattern does not work: \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\". Where could I make a mistake?\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @Avlaak :)\\r\\n\\r\\n>Can i set the number of characters for numbers (from 1 to 2)\\r\\n\\r\\nThe best way I can think of, would be to use \\\\d\\\\d? like you are suggesting.\\r\\n\\r\\nYou should be able to match `\\\"00:00:00\\\"` using the pattern `\\\\d\\\\d?:\\\\d\\\\d?:\\\\d\\\\d?`.\\r\\n\\r\\n\\r\\n>Where could I make a mistake?\\r\\n\\r\\nRemember that you need to escape the backslash `\\\\` when coding C, so the pattern `\\\\d\\\\d?` becomes `\\\\\\\\d\\\\\\\\d?`. Like this for instance: \\r\\n```C\\r\\nchar* pattern = \\\"\\\\\\\\d\\\\\\\\d?\\\"; /* <-- note the escaped-backslashes */\\r\\n```\\r\\n\\r\\nCould this be the problem?\\r\\n\\r\\n\\r\\n\\r\\nI tested the pattern by adding the following test cases to [test1.c](https://github.com/kokke/tiny-regex-c/blob/master/tests/test1.c) - and they all succeed :\\r\\n\\r\\n```C\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"0:0:0\\\"    },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"0:00:0\\\"   },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"0:0:00\\\"   },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"00:0:0\\\"   },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"00:00:0\\\"  },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"00:0:00\\\"  },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"0:00:00\\\"  },\\r\\n{ OK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"00:00:00\\\" },\\r\\n```\\r\\n\\r\\n\"}, {\"author\": \"Avlaak\", \"body\": \"Hi @kokke!\\r\\nI  also added following test cases to [test1.c](https://github.com/kokke/tiny-regex-c/blob/master/tests/test1.c) and I got the result \\\"48/54 tests succeeded\\\". \\r\\n\\r\\n```\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"0s:00:00\\\"  },\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"000:00\\\"    },\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"00:0000\\\"   },\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"100:00:00\\\" },\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"00:100:00\\\" },\\r\\n  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",  \\\"00:00:100\\\" },\\r\\n```\\r\\nAny string matches the pattern.\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Hi @Avlaak - it looks like you have found a bug in the non-greedy quantifier `?`.\\r\\n\\r\\nI did some testing, and it looks like it is the non-greedy quantifier that causes the pattern to match too broadly.\\r\\n\\r\\nI will keep this issue open, label it as a bug and add a note in the TODO-list in the README, that it needs to be looked at.\"}, {\"author\": \"kokke\", \"body\": \"I've uploaded some changes that should fix your problem - at least the ones we've identified in this issue :)\\r\\n\\r\\nLet me know if the last commits fix your problem.\"}, {\"author\": \"Avlaak\", \"body\": \"Hi @kokke, unfortunately the problem has remained, try to test the pattern.\\r\\n```  { NOK,  \\\"\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?:\\\\\\\\d\\\\\\\\d?\\\",   \\\"a:0\\\"            },```\"}, {\"author\": \"kokke\", \"body\": \"Hmm I need to think a bit deeper about this then.\\r\\n\\r\\nIt looks like the bug is still in the code handling the question-mark.\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Closing after merging #17. The randomized test-suite still doesn't run without errors on my machine, but at least the reported failing cases now pass :)\\r\\n\\r\\nAll-in-all #17 seems to improve correctness\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_13", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"13\", \"title\": \"Python version shenanigans\", \"author\": \"roflcopter4\", \"labels\": [], \"description\": \"This is about the tiniest issue ever, but I figured I'd ask anyway. Many platforms (certainly at least ArchLinux and Gentoo) these days use python3 as the standard python implementation. The scripts included are all definitely python2 code and thus the tests fail immediately. It took approximately 3 seconds to type `$ perl -pi -e 's/python/python2/g' Makefile scripts/*.py` to fix it completely, but it might be nice if you'd incorporate this into the source itself.\\r\\n\\r\\nAgain, not really much of an issue, but worth pointing out anyway.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @roflcopter4 and thanks for checking out the project :) I like the idea to be python3 compatible. Would your suggested fix be backward-compatible with machines without python3 installed?\\r\\n\\r\\nIf so, I suggest you make a PR and I'd gladly accept it :) ?\"}, {\"author\": \"kokke\", \"body\": \"Closing because I merged your PR https://github.com/kokke/tiny-regex-c/pull/14 :) \\r\\n\\r\\nThanks again @roflcopter4 \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_15", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"15\", \"title\": \"Problem into \\\".?\\\" matching.\", \"author\": \"TermoSINteZ\", \"labels\": [], \"description\": \"https://github.com/kokke/tiny-regex-c/blob/bf9b2f0c5e91dd12e1fea8cbc7ae7a6193e7b4ed/re.c#L382\\r\\n\\r\\nHello kokke! You have very good parser. But some improvement will be good inserting. \\r\\nSo \\r\\nChecked string : \\\"real_bar\\\" with regexp \\\".?ba.*\\\" - you have match into 0 index (correct result 4 index)\\r\\nChecked string : \\\"real_foo\\\" with regexp \\\".?ba.*\\\" - you have match into 0 index (correct result -1 (or nothing match)\\r\\n\\r\\nIf necessary - I can give you an example of a solution\", \"comments\": [{\"author\": \"TermoSINteZ\", \"body\": \"You can see possible solution into my fork:\\r\\nhttps://github.com/TermoSINteZ/tiny-regex-c\"}, {\"author\": \"kokke\", \"body\": \"Hi @TermoSINteZ and thank you for the kind words :)\\r\\n\\r\\nGreat job on fixing the bugs! I will copy the code right away - unless you want to make a Pull Request and get on the contributor list? I will gladly accept a PR.\"}, {\"author\": \"TermoSINteZ\", \"body\": \"Thanks\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_18", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"18\", \"title\": \"Could you submit a version support \\\"{}\\\" ?\", \"author\": \"ShuHu2015\", \"labels\": [], \"description\": \"for example \\\"^28\\\\d{15,16}$\\\"\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @ShuHu2015 and thanks for your interest :)\\r\\n\\r\\nSupporting curly-braces would require a radical change in the current design, so unfortunately no, that is not an option.\"}, {\"author\": \"ShuHu2015\", \"body\": \"Thanks for your reply! I am working on embed application now.\\r\\nso do you know any regex lib support curly-braces?\\r\\nThanks very much for your helps.\"}, {\"author\": \"kokke\", \"body\": \"Hi @ShuHu2015 \\r\\n\\r\\nThis library is popular: https://www.pcre.org/\"}, {\"author\": \"ShuHu2015\", \"body\": \"pcre is a big project. It is too hard for me to port pcre to my embed system....\"}, {\"author\": \"kokke\", \"body\": \"I don't know of other regex libraries suitable for embedded use.\"}, {\"author\": \"monolifed\", \"body\": \"This is a good starting point to look for simple libraries:  \\r\\nhttps://github.com/nothings/single_file_libs\\r\\n  \\r\\nThis seem to support curly braces:  \\r\\nhttps://github.com/ccxvii/minilibs/blob/master/regexp.c\\r\\nThis might support it one day:  \\r\\nhttps://github.com/gingerBill/gb/blob/master/gb_regex.h\\r\\n(I checked neither of them. So no idea about how they perform)\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Hi @ShuHu2015 \\r\\n\\r\\n@monolifed now has a branch of this library, that supports quantifiers / curly-braces as well :D\\r\\n\\r\\nAvailable from: https://github.com/monolifed/tiny-regex-c/tree/quantifier\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_19", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"19\", \"title\": \"Typo bug in re.c\", \"author\": \"tobermory\", \"labels\": [], \"description\": \"At line 288 of re.c, there is a '==' operator between the tests for c == 'S' and c == 'w' that I think should be a '||'.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @tobermory I would definitely agree that it's a mistake on my behalf :)\\r\\n\\r\\nThanks for spotting this -- I have committed a change that fixes this, referencing this issue :)\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_20", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"20\", \"title\": \"Match question mark fails?\", \"author\": \"tobermory\", \"labels\": [], \"description\": \"If my pattern is X?Y and my text is 'Z' I would expect this to not match, but it appears that it is matching?  I think the logic in matchquestion is wrong.  Once the two tests in that routine fail, we pass through to a result of 1, which becomes the result of the overall matchpattern.  The remainder of the pattern isn't ever consulted.\\r\\n\\r\\nAlso, and this may be related, the pattern indices in the recursive and iterative matchpattern routines don't match.  I'm not saying that they should, just noting their differences.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @tobermory - thanks for reporting this issue.\\r\\n\\r\\nI agree, \\\"X?Z\\\" should not match \\\"Z\\\". \\r\\nThis is a bug in the question-mark matching code, but I am not quite sure how to fix it.\\r\\n\\r\\nFor now, I will add your failing test-case to the list of hand-picked tests in the test-suite.\\r\\nAt least that makes it visible that something is failing in that area.\\r\\nThat also means I can track when it gets fixed -- that's a start.\\r\\n\\r\\nIf you have time to look at it, feel free to submit a Pull Request fixing the issue.\\r\\n\\r\\n\\r\\nRegarding the index-difference between the iterative and the recursive version -- that looks suspicious, I agree.\\r\\n\\r\\n\"}, {\"author\": \"monolifed\", \"body\": \"```C\\r\\nstatic int matchquestion(regex_t p, regex_t* pattern, const char* text)\\r\\n{\\r\\n  // end of pattern\\r\\n  if(p.type == UNUSED)\\r\\n    return 1;\\r\\n  // already matches without optional part\\r\\n  if (matchpattern(pattern, text))\\r\\n      return 1;\\r\\n  // optional part matches; advance\\r\\n  if (*text && matchone(p, *text))\\r\\n    return matchpattern(pattern, text + 1);\\r\\n  return 0;\\r\\n}\\r\\n```\\r\\nI hope this works better than the last time\\r\\n(It still fails some of the `make test` tests)\\r\\n\\r\\nEdit:\\r\\nI believe first one `\\\\d+\\\\w?\\\\D\\\\d` fails because it generates strings for `\\\\d+\\\\w?\\\\d\\\\d`\\r\\nThe second `a?b[ac*]*.?[\\\\]+[?]?` fails because of the part `[\\\\]+[?]` (`\\\\]` is not handled so the first `]` ends the class)\"}, {\"author\": \"kokke\", \"body\": \"Hi @monolifed and thanks for contributing :)\\r\\n\\r\\nI am not near a computer now, but I will review your suggested changes and try to see if I can make sense of the failing cases. \\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Hey @monolifed - I just had a few minutes to look at this again.\\r\\nI think I agree with your diagnosis of the first failing case:\\r\\n\\r\\n>   pattern '\\\\d+\\\\w?\\\\D\\\\d':                FAIL : doesn't match '18' as expected [0x31, 0x38].\\r\\n\\r\\n'18' does indeed not match `\\\\d+\\\\w?\\\\D\\\\d`, so something is wrong with the input data being generated.\\r\\nShould be possible to find the problem and fix that in the Python code.\\r\\n\\r\\nHaven't had the time to look at the second failing case yet, but your explanation sounds plausible. Failing to handle the backspace as a character-class `[\\\\]` would explain the failure.\\r\\n\\r\\nI will try to review ASAP, but I may not have the time before the end of this week.\\r\\n\\r\\nI suggest you make a pull request containing the changes, which I will then merge.\\r\\nThat way, you  get proper attribution for the fix :)\\r\\n\\r\\n\"}, {\"author\": \"monolifed\", \"body\": \"```diff\\r\\n        /* Copy characters inside [..] to buffer */\\r\\n        while (    (pattern[++i] != ']')\\r\\n                && (pattern[i]   != '\\\\0')) /* Missing ] */\\r\\n        {\\r\\n          if (ccl_bufidx >= MAX_CHAR_CLASS_LEN) {\\r\\n              //fputs(\\\"exceeded internal buffer!\\\\n\\\", stderr);\\r\\n              return 0;\\r\\n          }\\r\\n+++          if (pattern[i] == '\\\\\\\\')\\r\\n+++            ccl_buf[ccl_bufidx++] = pattern[i++];\\r\\n          ccl_buf[ccl_bufidx++] = pattern[i];\\r\\n        }\\r\\n```\\r\\nthis seems to fix unhandled `\\\\]` in char-class but there is a possibility of overflow\\r\\n(ccl_bufidx == MAX_CHAR_CLASS_LEN - 1 && pattern[i] == '\\\\\\\\')\"}, {\"author\": \"kokke\", \"body\": \"@monolifed \\r\\n\\r\\nThis should be closed no?\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_21", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"21\", \"title\": \"can not match such string “869759002514931”\", \"author\": \"violet701\", \"labels\": [], \"description\": \"the string is just  15 fixed digits witch is start by \\\"86\\\". i have check the pattern \\\"\\\\\\\\d{15}\\\", \\\"[0-9]{15}\\\" ,\\\"^[0-9]{15}$\\\" and they all cannot match correctly. what is wrong with it?\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @violet701\\r\\n\\r\\nThe quantifier-operator (`{number-of-matches}`, `{min-matches, max-matches`) is not supported. I think that's the problem you're experiencing.\\r\\n\\r\\nAs a small hack, maybe you can replace `\\\\d{15}` with `\\\\d+` or `\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d`...?\\r\\n\"}, {\"author\": \"monolifed\", \"body\": \"Adding the matching function doesn't seem hard\\r\\n```C\\r\\nstatic int matchquantifier(regex_t p, regex_t* pattern, const char* text, int min, int max)\\r\\n{\\r\\n  max -= min;\\r\\n  while (min > 0 && *text && matchone(p, *text++))\\r\\n  {\\r\\n    min--;\\r\\n  }\\r\\n  if (min > 0)\\r\\n    return 0;\\r\\n  do\\r\\n  {\\r\\n    if (matchpattern(pattern, text))\\r\\n      return 1;\\r\\n    max--;\\r\\n  }\\r\\n  while (max > 0 && *text && matchone(p, *text++));\\r\\n\\r\\n  return 0;\\r\\n}\\r\\n```\\r\\nBut you'd probably need another array to store mins and maxs\"}, {\"author\": \"kokke\", \"body\": \"Hi @monolifed \\r\\n\\r\\nMaybe you could extract the min/max limits from the pattern before calling the matching function, avoiding the need to add extra variables holding the min/max values?\"}, {\"author\": \"monolifed\", \"body\": \"Right.\\r\\nhttps://github.com/monolifed/tiny-regex-c/tree/quantifier\"}, {\"author\": \"kokke\", \"body\": \"Wow that looks really promising @monolifed :) i will review the code later today / this evening. \\r\\n\\r\\nI expect i will merge your PR #22 as well :)\\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"@monolifed \\r\\n\\r\\nI have run a few tests on your quantifier-branch, and I really like it so far.\\r\\n\\r\\nIf you make another PR adding the quantifier functionality (or add it to #22), I will merge it.\\r\\n\\r\\n\"}, {\"author\": \"violet701\", \"body\": \"oh, it's GREAT!!! \"}, {\"author\": \"kokke\", \"body\": \"Hey @monolifed - will you make a PR with the quantifier-addition? I think I somehow dropped this on the floor.\\r\\n\\r\\nI am not sure how to review which additions were made besides the addition of the matchquantifier-function. Maybe you have a better recollection/overview?\"}, {\"author\": \"monolifed\", \"body\": \"I don't really remember well\"}, {\"author\": \"kokke\", \"body\": \":laughing: \\r\\n\\r\\nI'll try and see if I can get time to clone the branch, pull from master and diff against it. That should do it no? I don't think that branch is any unmergeable changes behind.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_24", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"24\", \"title\": \"End of match\", \"author\": \"jkhax0r\", \"labels\": [], \"description\": \"The re_match() routine returns the first character of the match.  Is there an easy way to return the last matching character of the string?  I'm trying to copy out only the resulting matching string but can't think of an easy way.  \\r\\n\\r\\nGreat library by the way! \", \"comments\": [{\"author\": \"kokke\", \"body\": \"The length of the match can now be returned as per #36 \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_27", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"27\", \"title\": \"Does not work for GUUID validation\", \"author\": \"tawmoto\", \"labels\": [], \"description\": \"Hello, it seems that it does not work for GUUID validation\\r\\n\\r\\n```\\r\\nconst char* pattern = \\\"^([0-9A-Fa-f]{8}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{4}[-][0-9A-Fa-f]{12})$\\\";\\r\\nint m = re_match(pattern, \\\"CA761232-ED42-11CE-BACD-00AA0057B223\\\");\\r\\n```\\r\\n\\r\\nThis works with online tools https://regex101.com/r/hD8sJ8/3\\r\\n\\r\\nThank you\\r\\n\", \"comments\": [{\"author\": \"ToriningenGames\", \"body\": \"Disclaimer: I am not the maintainer.\\r\\n\\r\\nYour regex contains quantifiers (`{8}` etc.). Currently, they are not supported (ref. Issues #18, #29).\\r\\nFor this reason, I'd expect your regex to fail. Issue #29 points to a fork that, while out of date, does support quantifiers. Or, while more tedious and harder to maintain, repeating the character group prior to the quantifier would work.\"}, {\"author\": \"monolifed\", \"body\": \"It supports match length now. You can do it with a few matches\\r\\n\\r\\nThere is another fork that supports quantifiers: https://github.com/monolifed/tiny-regex-mod\"}, {\"author\": \"rurban\", \"body\": \"My [times](https://github.com/rurban/tiny-regex-c/tree/times) branch also supports this.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_28", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"28\", \"title\": \"Capture group\", \"author\": \"gogo9th\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nI am looking for a C source code for regular expression that supports finding matchings substrings for capture groups. I seems that tiny-regex-c doesn't support it... I wonder if you happen to know any other C libraries that support this feature. Thanks for your help.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @gogo9th and thanks for checking out this library.\\r\\n\\r\\nI don't know of other small libraries that support capture-groups, but I'm fairly certain that the PCRE library supports it. \\r\\n\\r\\nhttps://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions\\r\\nhttps://www.pcre.org/\\r\\n\\r\\nOtherwise, I recommend that you check out the forks of this project, as some of them really have extended the functionality. There may be someone out there who have finished capture groups.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_29", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"29\", \"title\": \"Simple Date format not matched\", \"author\": \"gjois\", \"labels\": [], \"description\": \"Please check this site for example: https://regex101.com/r/ZqMTdp/1\\r\\nthe same input to your sample program is not giving the match. Am I missing something?\\r\\nI'm really a newbie in regexp.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @gjois and thanks for the question\\r\\n\\r\\nCurrently, quantifier-operators are unsupported, and your regular expression is using those operators.\\r\\n\\r\\nIn this regular expression: `\\\\d{4}-\\\\d{2}-\\\\d{2}` <-- the quantifiers are {4}, {2}  and {2}. \\r\\n\\r\\nYou should be able to achieve the same result with this pattern: `\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d`.\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"This fork has support for quantifiers: https://github.com/kokke/tiny-regex-c/pull/23\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_30", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"30\", \"title\": \"Memory Corruption Vulnerabilities\", \"author\": \"neilsikka\", \"labels\": [], \"description\": \"This project has memory safety vulnerabilities due to off-by-1 pointer management. For example, running: \\\"tiny-regex-c.exe [\\\" produces the following output:\\r\\ntype: CHAR_CLASS []\\r\\ntype: CHAR '²'\\r\\ntype: CHAR '²'\\r\\ntype: CHAR '²'\\r\\ntype: CHAR '²'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\ntype: CHAR 'á'\\r\\n\\r\\nThis test case is reading past the end of the character buffer until the next NULL terminator is found. I identified issues in both re_print and re_compile in the above testcase. Vulnerabilities such as this can allow attackers to exploit systems or projects that embed this code.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @neilsikka - yes indeed, if you provide an incomplete regex-pattern ('tiny-regex-c.exe [' is an unmatched character class if I am not mistaken), memory corruption will ensue.\\r\\n\\r\\nIf you are concerned about security problems, this library is not for you. \\r\\n\\r\\nIf you want a small implementation of a regex library, with bugs etc. as described in the README, the project may be of interest.\\r\\n\\r\\nEDIT:\\r\\nI think this has been fixed in #44. I am unsure how to reproduce though, so will not re-open.\\r\\nI still think you should consider other libraries for serious business, if you can.\\r\\nMuch was sacrificed for minimalism in tiny-regex, and I think e.g. PCRE is both faster and more thoroughly tested than this library could ever be.\"}, {\"author\": \"snej\", \"body\": \"If you’re not going to fix this, the responsible thing would be to put a big boldface disclaimer in the README saying that “**this library does not check patterns for validity, and may produce undefined behavior including memory corruption when given an invalid pattern.**”\\r\\n\\r\\nOtherwise users will naturally assume the library rejects invalid patterns (or at worst produces invalid output without undefined side effects), since that’s how every other regex library I can think of works. And it would be all too easy to decide to use this in a situation where the patterns consist of untrusted input.\\r\\n\\r\\nThe term “[Attractive Nuisance](https://www.dictionary.com/browse/attractive-nuisance)” comes to mind.\"}, {\"author\": \"kokke\", \"body\": \"Hi @snej - is this still an issue?\\r\\n\\r\\nFrom this thread: https://github.com/kokke/tiny-regex-c/issues/44 and the discussion, I got the impression that these issues were squashed.\\r\\n\\r\\nI am not near a computer now, so can’t test myself. \\r\\n\\r\\nIf this is indeed still an issue, I will add a warning about incorrect usage as you suggest.\\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"@snej \\r\\nTo summarize and give you some context: #44 and the changes that ensued (see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b), made the library pass formal verification by KLEE. \\r\\n\\r\\nAfter those changes, I removed the warning in the readme about not validating erroneous regex patterns.\\r\\n\\r\\nI will appreciate a piece of code or a command so I can reproduce the alledged problem in a case such as this. Or even better (if possible): a PR fixing the problem. \"}, {\"author\": \"kokke\", \"body\": \"@snej \\r\\nI had the chance to run KLEE on the code and (according to the tool) the code is proven free of run-time errors. So as far as I can tell, the bugs were indeed squashed in #44.\\r\\n\\r\\nTo be completely frank with you: I think you should have verified this for yourself, before chiming in on a closed issue from 2019.\\r\\n\\r\\nAnother approach would have been to just ask if this was fixed, before lecturing me on responsibility and \\\"attractive nuisances\\\". I did not appreciate that last comment and I found it accusing.\\r\\n\\r\\nI am sure you had the best intentions, but in my opinion your approach was ham-fisted.\\r\\n\\r\\nNo harm, no foul: Thanks for your interest in this project.\\r\\n\\r\\nBest wishes and I hope you will enjoy the weekend :)\"}, {\"author\": \"snej\", \"body\": \"My apologies — someone linked to this issue in a forum, and I stupidly didn't notice how old the timestamp was. 😔\\r\\nGlad it's fixed.\"}, {\"author\": \"kokke\", \"body\": \"Hi @snej - thanks for being so upfront and no worries at all :)\\r\\n\\r\\nHaving now seen the lobste.rs-post (mentioned in #57) I totally understand how that situation arose. I don't come back to edit all issues normally, so I can easily understand how it wasn't easy to spot how this had been fixed.\\r\\n\\r\\nI can see now, that my comment(s) were too harsh and dismissive - I apologize for that. I was in a rush when replying (chronic condition?) ...  I have edited the original post to substantiate my comment a bit.\\r\\n\\r\\nI am really surprised and happy to see my code mentioned on lobste.rs - but also a bit frustrated since I could not reply in the thread :laughing: \\r\\n\\r\\n\"}, {\"author\": \"snej\", \"body\": \"If you'd like an invite, email me (jens åt mooseyard døt cøm) ^_^\"}, {\"author\": \"kokke\", \"body\": \"```\\r\\n       _=_\\r\\n     q(-_-)p\\r\\n     ,<___/\\\\\\r\\n    (<_`. _/)\\r\\n   (_\\\\_\\\\_|_/_)\\r\\n   BUDDHA BLESS\\r\\n```\\r\\n\\r\\nThank you very much @snej - a good sport and a chummy lad etc. ;D\"}, {\"author\": \"kokke\", \"body\": \"BTW I hear you like capybaras, so here's one for you, free of charge\\r\\n\\r\\n```\\r\\n                                 .;o,\\r\\n        __.\\\"iIoi,._              ;pI __-\\\"-oO.,_\\r\\n      `.3\\\"P3PPPoie-,.            .d' `;.     `p;\\r\\n     `O\\\"dP\\\"````\\\"\\\"`PdEe._       .;'   .     `  `|   \\r\\n    \\\"$#\\\"'            ``\\\"P4rdddsP'  .F.    ` `` ;  \\r\\n   i/\\\"\\\"\\\"     *\\\"Sp.               .dPff.  _.,;Gw'\\r\\n   ;l\\\"'     \\\"  `dp..            \\\"sWf;fe|'\\r\\n  `l;          .rPi .    . \\\"\\\" \\\"dW;;doe;\\r\\n   $          .;PE`'       \\\" \\\"sW;.d.d;\\r\\n   $$        .$\\\"`     `\\\"saed;lW;.d.d.i\\r\\n   .$M       ;              ``  ' ld;.p.\\r\\n__ _`$o,.-__  \\\"ei-Mu~,.__ ___ `_-dee3'o-ii~m. ____\\r\\n```\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_31", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"31\", \"title\": \"Thread safety\", \"author\": \"ogamespec\", \"labels\": [], \"description\": \"https://github.com/kokke/tiny-regex-c/blob/d3058f271f7a06ff298dff0a6a9a1e0753a5fa17/re.c#L111\\r\\n\\r\\n\\r\\nLooks like its non thread safe (non-reentrant)\\r\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @ogamespec and thanks for your comment :)\\r\\n\\r\\nYour observation is totally correct: this code is not reentrant. \\r\\n\\r\\nThe code is targeted towards embedded and resource-constrained targets, where dynamic allocation is verboten and binary size matters.\\r\\n\\r\\nSome of the forks of this project vastly expands functionality and I also believes thread-safety is implemented in some of them. If this is a requirement for your use case, I would advise you to check out some of the forks, in particular the one by @monolifed :)\\r\\n\\r\\nAn easy fix/hack would be to either 1) pass the memory from the caller, or 2) place a lock/mutex inside the compile function.\\r\\n\\r\\n\"}, {\"author\": \"ogamespec\", \"body\": \"Resolved)\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_32", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"32\", \"title\": \"Compilation using VS2010\", \"author\": \"theo-dep\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nThank you for your code, it resolves an issue to use regex with gcc in very big string.\\r\\nVisual Studio 2010 needs perfect C code, and it is throw this error : \\r\\n~~~\\r\\nre.c(250) : error C2143: syntax error : missing ';' before 'type'\\r\\nre.c(251) : error C2143: syntax error : missing ';' before 'type'\\r\\n~~~\\r\\nTo resolve this issue, only `int i;` and `char c;` need to be moved in top of the function `void re_print(regex_t* pattern)`.\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_34", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"34\", \"title\": \"feature request: lookahead and lookbehind\", \"author\": \"theo-dep\", \"labels\": [], \"description\": \"feature request: https://www.regular-expressions.info/lookaround.html\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @theo-dep - how did the lookahead/behind work out for you? Did you ever implement this?\\r\\n\\r\\nAs mentioned in #38 I am considering re-implementing the data-model, but it would require some rewriting.. I don't think I will be adding any feature in the near future. I have a lot on the program privately that limits my time available for it.\"}, {\"author\": \"theo-dep\", \"body\": \"Hi, it is a long time ago, I do not remember if that code work 😅 and if I finally used it.\\r\\nDo not worry, I am in other project now, I wish to thank you for the future work!\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_38", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"38\", \"title\": \"need help in finding one of the two strings.\", \"author\": \"sukhchainn\", \"labels\": [], \"description\": \"I am having trouble finding the pattern to mach one of the two strings from a larger string.\\r\\n`re_t match_pattern = re_compile(\\\"I|Me\\\");`\\r\\n\\r\\nThe code above doesn't seem to work, what should I do?\", \"comments\": [{\"author\": \"benstigsen\", \"body\": \"Not sure if the `or` symbol works. It's not in any of the tests, and this is in the README:\\r\\n> Fix implementation of branches (|), and see if that can lead us closer to groups as well, e.g. (a|b)+.\\r\\n\\r\\nSo you could just match for `\\\"I\\\"` first, if not valid, match for `\\\"Me\\\"` after.\"}, {\"author\": \"sukhchainn\", \"body\": \"Can you suggest me a minimal regex library that supports` or` in groups?\"}, {\"author\": \"benstigsen\", \"body\": \"I have not found a \\\"good\\\" one yet. This is the closest to it that I've found so far. \"}, {\"author\": \"kokke\", \"body\": \"Hi @sukhchainn and thanks for the question\\r\\n\\r\\n@BenStigsen seems to have answered the question so I'll close the issue. If you have further comments, feel free to keep writing anyway.\\r\\n\\r\\nFYI I have considered including grouping `|` but it will require a rewrite I think, because the current data-model is becoming stretched.\\r\\n\\r\\nI am considering an implementation with 32-bit tokens as the regex_t elements, because it would enable encoding of more advanced features - at the cost of more memory-usage I'm afraid..\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"40\", \"title\": \"Understand metacharacters and escape character\", \"author\": \"StephenArk30\", \"labels\": [], \"description\": \"In most languages, the [escape character](https://en.wikipedia.org/wiki/Escape_character) is '\\\\\\\\'. Sequences start with an escape character have special meaning, eg: '\\\\n', '\\\\t'.\\r\\n\\r\\n[Metacharacters ](https://en.wikipedia.org/wiki/Metacharacter)are escape characters, but often match a group of characters, eg: '\\\\s' matches any whitespace like '\\\\t', '\\\\n'.\\r\\n\\r\\nSo, when we are matching single comment lines in C, we need to use:\\r\\n\\r\\n``\\\\/\\\\/[^\\\\n]*``,\\r\\n\\r\\ninstead of\\r\\n\\r\\n``\\\\/\\\\/[^\\\\\\\\n]*``\\r\\n\\r\\nwhich won't match a line break but a \\\"\\\\n\\\" string.\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @StephenArk30 and thanks for your comment\\r\\n\\r\\nI'm not really sure what you mean. Could you please have a look at https://github.com/kokke/tiny-regex-c/blob/master/tests/test1.c \\r\\n... and write a few test cases so I'm absolutely sure what we're talking about.\\r\\n\\r\\nI'm trying to mimic the Python implementation, but the code is in C which just handles escapes like that. Or maybe I'm misunderstanding you?\"}, {\"author\": \"marler8997\", \"body\": \"@kokke what he's asking for is this:\\r\\n```c\\r\\n  { OK, \\\"\\\\\\\\n\\\", \\\"\\\\n\\\",  (char*) 1 },\\r\\n  { OK, \\\"\\\\\\\\t\\\", \\\"\\\\t\\\",  (char*) 1 },\\r\\n```\"}, {\"author\": \"StephenArk30\", \"body\": \"Sorry for the late reply. This is just a note for some beginners who thinks themselves \\\"smart\\\" like me. Not asking for anything.\\r\\n\\r\\nSo the case was I was trying to matching single comment lines in C like \\\"// this is a comment\\\", and I used\\r\\n\\r\\n``\\\\/\\\\/[^\\\\\\\\n]*``\\r\\n\\r\\nbecause I thought I should keep the '\\\\\\\\'. But it didn't work so I created a pr [here](https://github.com/kokke/tiny-regex-c/pull/39) trying to match \\\"\\\\\\\\n\\\". But after some research, I realize it should be\\r\\n\\r\\n``\\\\/\\\\/[^\\\\n]*``\\r\\n\\r\\ninstead. The \\\"metacharacters\\\" mentioned in the pr are some characters like '\\\\s' which matches many different characters, so '\\\\n' should not be a metacharacter.\\r\\n\\r\\nThis might be a common mistake beginners will make so I put it here. Closed it if needed.\"}, {\"author\": \"marler8997\", \"body\": \"I think this would be a common mistake.  The first reason being that most regex implementations support standard escape sequences like `\\\\n` and `\\\\t` etc.  The second being the confusion that comes with including regex escape characters in C String literals which have to escape the regex escape character, `\\\\`.  Note that tiny-regex-c can support these escape sequences as well with a few lines of changes so it's up to @kokke as to whether it should be supported.  The python implementation supports it so that's one thing to consider.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_43", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"43\", \"title\": \"Prevent duplicate include  errors\", \"author\": \"skyformat99\", \"labels\": [], \"description\": \"re.h file   \\r\\nThe header and the tail of the file are added separately。\\r\\n\\r\\n#ifndef      __TINY_REGEX_C_\\r\\n#define     __TINY_REGEX_C_\\r\\n\\r\\n......................\\r\\n...................\\r\\n....................\\r\\n\\r\\n#endif\\r\\n\\r\\n\\r\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @skyformat99 and thanks for your interest 👍 \\r\\n\\r\\nIt’s a good idea and I agree that header include guards are needed. \\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Added in this commit: https://github.com/kokke/tiny-regex-c/commit/9d46276c48091a22ac4fa6472603fe4b17d483ce\"}, {\"author\": \"kokke\", \"body\": \"Once again, thanks for pointing it out @skyformat99 \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_44", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"44\", \"title\": \"Two minor overflows in re_compile\", \"author\": \"DavidKorczynski\", \"labels\": [], \"description\": \"I found two minor overflows in `re_compile`:\\r\\n\\r\\n## First overflow\\r\\nThe first one is on line 121:\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L121\\r\\n\\r\\nThe bug is triggered with the following buffer input to the function: `\\\"\\\\\\\\\\\\x01[^\\\\\\\\\\\\xff][^\\\\x00\\\"`\\r\\n\\r\\nThe overflow happens because of the `[^` characters in the buffer, in particular if execution enters the condition:\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L173\\r\\n\\r\\nThen the following code will execute:\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L179-L190\\r\\n\\r\\nwhere `i` is increased on line 181 and 190, and finally before the loop continues `i` will be increased again:\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L226-L229\\r\\n\\r\\nWhich causes the overflow to happen on \\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L121\\r\\nsince `i` will now be 1-byte off in the buffer. \\r\\n\\r\\n## Second overflow\\r\\nThe second overflow happens on line 190:\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L190\\r\\n\\r\\nThis bug happens in case the following buffer is given to the function: `\\\"\\\\\\\\\\\\x01[^\\\\\\\\\\\\xff][\\\\\\\\\\\\x00\\\"`\\r\\n\\r\\nThe bug happens in the code:\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L173-L192\\r\\n\\r\\nThis happens because of the code:\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/9d46276c48091a22ac4fa6472603fe4b17d483ce/re.c#L190-L201\\r\\n\\r\\nWhere `i` is increased in size on lines: 190 and also line 200. Because `i` is increased on line 200 in case of a `\\\\` character, `i` will be one out of bounds on line 190 when the while loop enters the second iteration. \", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @DavidKorczynski and thanks for the thorough explanation.\\r\\n\\r\\nJust to make sure I understand the report correctly: You are passing an incomplete regex-pattern right? \\r\\n\\r\\n`\\\"\\\\\\\\\\\\x01[^\\\\\\\\\\\\xff][\\\\\\\\\\\\x00\\\"` looks like it's missing a closing bracket at the end `]` ?\\r\\n\"}, {\"author\": \"DavidKorczynski\", \"body\": \"Yes, that's correct! These are an invalid regex patterns - I was only reporting this because of them being memory corruption bugs. If you define your library such that it expects valid regex patterns and otherwise have undefined behavior then the bugs are not in scope as such.\"}, {\"author\": \"kokke\", \"body\": \"Thanks for the update.\\r\\n\\r\\nPlease don't mistake my response for disregard. I really appreciate that you've taken the time to document this defect so thoroughly.\\r\\n\\r\\nThis code does expect valid regex patterns, but still it is not very nice to segfault or corrupt memory. I have always loathed the missing validation but I left it out because I thought implementing it would require too much energy - and code! this project aims for small footprint.\\r\\n\\r\\nHowever I don't think it would require much code nor energy to fix this problem for character-classes, so I'll give it some thought and see if I can think of a good fix.\\r\\n\\r\\nIf you have any good ideas for a fix, don't hesitate to share your thought or make a PR.\"}, {\"author\": \"DavidKorczynski\", \"body\": \"Sounds good @kokke - your design choices make sense to me and thanks for the kind and quick replies.\\r\\n\\r\\nI filed an issue of the bugs because I am making some educational videos on how to use program analysis tools (symbolic execution) in order to analyse the properties of a code base, and your project is a nice project for demonstration purposes because, as you write, it has a small footprint. If you are interested I could share a link to the videos (they are freely available on Youtube). \\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Thanks for the kind words @DavidKorczynski :) \\r\\n\\r\\nMost (all?) of my public projects are designed to be runnable on embedded platforms, and usually that means I make some harsh compromises.\\r\\n\\r\\nWhat a coincidence, I love static analysis! I would love to see whatever material you have available :)\\r\\n\\r\\nI dabble with static analysis myself, mostly data-flow analysis and abstract interpretation, but I am not picky :D\\r\\n\\r\\nI am loving the videos of Christopher Reichenbach, e.g. this one https://www.youtube.com/watch?v=NVBQSR_HdL0 \"}, {\"author\": \"kokke\", \"body\": \"... and if I may ask, how do you find projects well suited for static analysis yourself? I have stumbled into this problem just recently.\\r\\n\\r\\nI've made a tool that clones a bunch of repos with C-code and runs my analysis-tool on them. Currently, I am just finding repos manually through Github's webpage and copy/pasting the repo-links, which gets tedious...\"}, {\"author\": \"DavidKorczynski\", \"body\": \"Awesome :)! I will add a link here when I upload the video - which should happen in one of the coming days.\\r\\n\\r\\nThat's great with data-flow analysis and abstract interpretation. I have used both extensively, and my PhD thesis involved a lot of (dynamic) taint analysis to analyse malware (you can find it on the Oxford University Research Archive here: https://ora.ox.ac.uk/objects/uuid:ef3faf5e-7733-4460-bba4-9e18893dec1e). Program analysis and software verification is my kind of jam too! \\r\\n\\r\\nI haven't seen those videos before, but by skimming through the one you link to it seems to cover the topics nicely! \\r\\n\\r\\nAbout target selection it really varies depending on the properties of the tool I am testing and the specific aspects of the tool that I am testing (edge-case/large-scale/educational demonstration/user interface/ etc.). In general I think your approach is largely the same approach as I do and also how other researchers who test tools. It can be quite a tedious process for sure, and doing a full empirical-analysis of your tool can take months of effort too. In general it's probably good to have a collection of repositories in your sleeve that you can pull out in different contexts - that will carry you a long way I think and often give you quick insights about the properties of your tool(s). Is your tool available somewhere :)? \\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"> Awesome :)! I will add a link here when I upload the video - which should happen in one of the coming days.\\r\\n\\r\\nNice! I'm looking forward to seeing the video. There are too few videos on static analysis in my opinion. Also thanks for taking the time to answer my questions.\\r\\n\\r\\n>That's great with data-flow analysis and abstract interpretation. I have used both extensively, and my PhD thesis involved a lot of (dynamic) taint analysis to analyse malware (you can find it on the Oxford University Research Archive here: https://ora.ox.ac.uk/objects/uuid:ef3faf5e-7733-4460-bba4-9e18893dec1e). Program analysis and software verification is my kind of jam too!\\r\\n\\r\\nI'll take a look at your thesis and see how much I understand :) I majored in EE/CS and only did introductory coursework on formal methods and static analysis, so there is a lot of notation/syntax that I don't understand and a lot of branches of math that I am not familiar with. Often times I struggle to read current published research, and need to look much up on wikipedia alongside. Some of the older stuff is more forgiving :D\\r\\n\\r\\n>About target selection it really varies depending on the properties of the tool I am testing and the specific aspects of the tool that I am testing (edge-case/large-scale/educational demonstration/user interface/ etc.). In general I think your approach is largely the same approach as I do and also how other researchers who test tools. It can be quite a tedious process for sure, and doing a full empirical-analysis of your tool can take months of effort too. In general it's probably good to have a collection of repositories in your sleeve that you can pull out in different contexts - that will carry you a long way I think and often give you quick insights about the properties of your tool(s). \\r\\n\\r\\nOkay - I was hoping that the Github API could be of some help in automating the process, but haven't RTFM yet. \\r\\nI have often used the [Toyota ITC benchmark](https://github.com/regehr/itc-benchmarks) suite as a first target to get an idea of coverage of very basic errors. I know the suite has flaws, but it also does test a pretty wide range of defects so I find it useful.\\r\\n\\r\\n> Is your tool available somewhere :)?\\r\\n\\r\\nNo. I don't have a well-enough working tool at the moment. I only have toy prototypes and a tool that I have donated to my workplace and worked on there (so not allowed to share the code). It is basically just a (much) more developed version of [tiny-lint](https://github.com/kokke/tiny-lint-c) working with pattern-matching at the syntax level, i.e. not very technologically advanced. That level of sophistication can go a long way though! [cppcheck](https://github.com/danmar/cppcheck) works great on embedded code with static allocation. It also scales well, which none of my prototype tools do :( \\r\\n\\r\\nCurrently I mostly make toy scripts to test various implementation strategies for the abstract domain. I am trying to understand [Anders Møller's course notes](https://cs.au.dk/~amoeller/spa/spa.pdf) but I am still struggling a bit with both theory and practice :D\\r\\nOtherwise I write scripts for pycparser to manually roll-out loops to get branchless code, insert assertions, adjust error-output by abusing/spamming the #line directive and feeding it to FOSS tools :D it's a mess, but it has worked fantastically for me.\\r\\n\\r\\nI have somewhat emulated the approach taken by [CBMC](http://www.cprover.org/cprover-manual/cbmc/). I want to get closer, which is why I have begun studying abstract interpretation and have begun trying to emit constraints to an SMT solver. In my testing the standard integer interval domain is a bit too coarse, and finite sets scale horribly.. I am struggling with encoding the maths of more advanced theories in the SMT solver..\\r\\n\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"Hi @DavidKorczynski - I think I have a solution.\\r\\n\\r\\nIt's not the best solution, but it's the easiest for now.\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b\\r\\n\\r\\nThe better solution would be to pass a length of the pattern as well, and replace all null-checks with checks against the length of the string. That would enable handling of regex patterns over binary data.\\r\\n\\r\\nI've added two test-cases for the patterns you've reported, see [test_compile.c](https://github.com/kokke/tiny-regex-c/blob/master/tests/test_compile.c).\\r\\n\\r\\nIf you can come up with more examples, please let me know. \"}, {\"author\": \"Nable80\", \"body\": \"Hi @kokke \\r\\nI came across dbde6da49707a6008d33fb4ccc7d84cac79ae1f5 in my recent notifications and there are few code style related questions that I'm too tempted to ask:\\r\\n1. Why do you need a mutable copy of ``pattern1``/``pattern2``? My personal rule of thumb is that everything should be ``const`` except those things that can't be constants due to some obvious reasons. Do you share this idea?\\r\\n2. Is there any need for variables at all? I've checked that ``re_compile``'s argument type is ``const char *``, so it's possible to write just ``re_compile(\\\"expression\\\")`` or ``const char *pattern1 = \\\"...\\\"; void *p1 = re_compile(pattern1)`` if it provides any additional readability.\\r\\n3. Is there any reason to use ``0`` instead of ``NULL`` when you're comparing pointers?\\r\\nThere's a similar question about ``'\\\\0'`` vs ``0`` in e.g. 1a279e04014b70b0695fba559a7c05d55e6ee90b (they say, explicit is better than implicit, heh).\\r\\n\\r\\nIt doesn't change anything in tests but similar constructions may affect something in other parts of code and I'm thinking about code style consistency across all files in the project.\\r\\n\\r\\nProbably I'm not the first one who asks these questions, I hope it doesn't annoy you.\"}, {\"author\": \"kokke\", \"body\": \"Hi @Nable80 - you're always welcome to ask questions :)\\r\\n\\r\\n1) There is no need for a mutable copy at all. A `const char*` would do just fine. I just wanted tests for the failure-cases, to verify whether or not my proposed fix would work. I like the idea about const-strictness, but I am not too good myself at using `const` I must admit. In C const has less \\r\\n\\r\\n2) There is no need for variables either :) I made a few changes that takes some of your points into consideration: https://github.com/kokke/tiny-regex-c/commit/71eb437a5005038182283036463106e0be25671f -- any feedback is appreciated.\\r\\n\\r\\n3) To me there is not much difference between `\\\\0`, `NULL`, `0`, `0x00` etc. so it's just laziness on my part...\\r\\n\\r\\nConsistency is a virtue and I will make efforts to get `rc.c` cleaned up with a more consistent coding style :+1: \\r\\n\\r\\nYour questions are valid and I appreciate all the feedback I get, because it often improves the code or the documentation :)\"}, {\"author\": \"Nable80\", \"body\": \"Thank you very much for your kind replies!\\r\\n\\r\\n> In C const has less\\r\\n\\r\\nAre some words missing after this part in point 1? I think I got your idea anyway, ``const`` is quite limited in C due to backward compatibility reasons and it's really sad. I often use C for firmware and sometimes I have to use ``static const`` workaround, sometimes I just have to accept that compiler stores some constant array/structure as-is instead of tearing it into pieces and using this information to optimize-out all unused branches. It's still better nothing.\\r\\n\\r\\n> I made a few changes that takes some of your points into consideration: 71eb437\\r\\n\\r\\nIMHO loop isn't better here (unless you add more code to print additional details). E.g. previous version could fail with something like \\\"assertion failure at line 16\\\" or \\\"at line 20\\\" (at least some information about failed test) but now it's always \\\"line 25\\\", no matter which expression fails. IMHO it's better to just shorten the previous version and add a one-line comment to each expression, something like this:\\r\\n```c\\r\\nint main()\\r\\n{\\r\\n  /* Test 1: inverted set without a closing ']' */\\r\\n  assert(re_compile(\\\"\\\\\\\\\\\\x01[^\\\\\\\\\\\\xff][^\\\") == NULL);\\r\\n\\r\\n  /* Test 2: set with an incomplete escape sequence and without a closing ']' */\\r\\n  assert(re_compile(\\\"\\\\\\\\\\\\x01[^\\\\\\\\\\\\xff][\\\\\\\\\\\") == NULL);\\r\\n\\r\\n  return 0;\\r\\n}\\r\\n```\\r\\n\\r\\nIt looks OK to me when there aren't much tests. When (if) their number grows to some degree, it would be time to start using some auto-test library with all its macro expressions, rules, fancy output, etc.\\r\\n\\r\\nBtw, if you're interested in static analysis, here are the gcc/clang flags that I consider mandatory in my C projects (note: I don't use C++, that's why several well-known flags are absent here): ``-Wall -Wextra -Wnarrowing -Wwrite-strings -Wcast-qual -Werror``, they work best when combined with ``-O2 -fomit-frame-pointer -flto`` because some analysis checks are parts of optimization passes, so they're not called if you don't enable optimizations, sometimes bugs can only be found with intermodular analysis, thus the ``-flto`` flag.\\r\\n\\r\\nIt may also be interesting to try PVS-Studio. Warning: it's not free software at all (thus I can't recommend using it) but they offer licenses for free to all enthusiasts, AFAIR you don't even have to write them nowadays, one should just download it to an isolated VM and follow the instructions on their site. They often test their tool on different open-source projects and publish reports and explanations, you may use these reports at least as a source of interesting projects to test with your tools and compare results.\"}, {\"author\": \"kokke\", \"body\": \">Are some words missing after this part in point 1? \\r\\n\\r\\nHaha yes indeed - how did I miss that.. I was starting a paragraph about how const is difficult to enforce etc.- you got the gist of it.\\r\\n\\r\\nValid critique of the loop-construct - I will refactor back to your suggestion, which is clearer and yields better error messages (good point RE: \\\"assertion failed on line 25\\\").\\r\\n\\r\\nInteresting, I did not know about -Wnarrowing and -Wqual-cast. I will check if our gcc 4.x toolchain at work supports them.\\r\\n\\r\\nI mostly use the following set of warnings, along with -O2 or -Os, depending on need-for-speed or compactness:\\r\\n\\r\\n-Wall\\r\\n-Wextra\\r\\n-Wundef\\r\\n-Wstrict-prototypes\\r\\n\\r\\nI find -Wundef to be indispensable on a lot of C code bases: _\\\"Warn if an undefined identifier is evaluated in an #if directive. **Such identifiers are replaced with zero.**\\\"_ \\r\\n\\r\\nI haven't tried PVS-Studio because of the non-free licensing. I think I've tried most other FOSS tools for static analysis on C code :D I will try and see if I can get my hand on a personal/research license of PVS-Studio. Good point checking which projects PVS-Studio are scanning :+1: \"}, {\"author\": \"Nable80\", \"body\": \"> I will check if our gcc 4.x toolchain at work supports them.\\r\\n\\r\\nOh, it sounds like a somehow painful enterprise experience.\\r\\n\\r\\n> along with -O2 or -Os, depending on need-for-speed or compactness\\r\\n\\r\\nYes, I usually build with -O2 (desktop/server builds and sometimes I try to use it for firmware, just to compare size and check whether static analysis could find anything in addition to -Os level) or -Os (regular firmware builds) too.\\r\\n\\r\\nThank you for -Wundef and -Wstrict-prototypes, I thought they're part of -Wall or -Wextra but they aren't. I've added them to my Makefile and fixed several function definitions. While checking -Wundef documentation in ``man gcc`` I found -Wunused-macros and -Wbad-function-cast, they're not enabled by default but they look promising too. There's also -Wconversion flag (and several related flags) but it may require a lot of changes to properly fix all warnings that it enables. Yet it's still worth trying.\\r\\n\\r\\nI also found these lines today in my old notes: ```-pedantic -Wall -Wextra -Wunused-parameter -Wstrict-overflow=5 -Wundef -Wshadow -Wcast-qual -Wcast-align -Wconversion -Wsign-conversion -Wmissing-declarations -Wredundant-decls -Wdisabled-optimization -Woverloaded-virtual -Wctor-dtor-privacy -Wold-style-cast```\\r\\n```-Werror -Wall -Wextra -Wpedantic -Wcast-align -Wcast-qual -Wconversion -Wctor-dtor-privacy -Wenum-compare -Wfloat-equal -Wnon-virtual-dtor -Wold-style-cast -Woverloaded-virtual -Wredundant-decls -Wsign-conversion -Wsign-promo```\\r\\n```-ffast-math -ffp-contract=fast -fsingle-precision-constant -Wdouble-promotion```\\r\\n\\r\\nMost of these flags were already mentioned above or can be used with C++ only but it's still possible that you may find something interesting in this dump.\"}, {\"author\": \"DavidKorczynski\", \"body\": \"Just a quick update for now @kokke : The following link is the instructional video on how to use KLEE for analysis of open source projects, which is how I found the bugs reported in this issue : https://www.youtube.com/watch?v=XaYEmwVMRt4\"}, {\"author\": \"kokke\", \"body\": \"Hi @DavidKorczynski and thanks for the update. I never got back to you, because I had a feeling the second null-check could be avoided, if using the last fix (the one only present in my comments). I wanted to test that out, so I tried getting KLEE to compile and in my quest for that, I ended up doing a full system upgrade.\\r\\n\\r\\nIt went mostly like this:\\r\\n\\r\\n![...](https://imgs.xkcd.com/comics/success.png)\\r\\n\\r\\n... but with a more happy ending.\\r\\n\\r\\nI now have a current version of Debian, but I still can't compile KLEE :laughing: \\r\\n\\r\\nOh well, Docker is also nice :rofl: and I have a video-tutorial and everything :+1: \\r\\n\\r\\nOne small critique of the videos: The terminal/console font is almost too small for me. Even in full hd resolution, I have a hard time reading the text on my 14\\\" laptop.\\r\\n\"}, {\"author\": \"kokke\", \"body\": \"For now I have implemented all the null-checks discussed in https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b -- see commit https://github.com/kokke/tiny-regex-c/commit/349ef187d00444349a38cfc409b9f023a3c31e5f\"}, {\"author\": \"DavidKorczynski\", \"body\": \"Agrhh @kokke - I feel bad for starting this, which ended up having you do a system upgrade :S \\r\\n\\r\\nIt can be a bit of a pain to compile KLEE from source - there are quite a few components in place and it's not obvious at first. \\r\\n\\r\\nThanks a lot for the critique of the videos and I totally agree and good work on fixing the bugs, thanks for being so responsive. \"}, {\"author\": \"kokke\", \"body\": \"@DavidKorczynski !! I never gave you a proper reply... Thank you for taking the time to work with me and the project.\\r\\n\\r\\nI've made the page below where I've begun some KLEE-checking of the code, but I've only done re_compile() for now.\\r\\nDo you have any test-drivers lying around with more coverage that I could use, now that I'm namedropping you anyways? ;)\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/blob/master/formal_verification.md\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_47", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"47\", \"title\": \"Could not search for '.'\", \"author\": \"jaeung24k-sindoh\", \"labels\": [], \"description\": \"re_compile(\\\"[A-Z]:-?\\\\\\\\d+.\\\\\\\\d+\\\");\\r\\nor\\r\\nre_compile(\\\"[A-Z]:-?\\\\\\\\d+[.]\\\\\\\\d+\\\");\\r\\n\\r\\nCan't distinguish between X:12.34 and X:1234.\", \"comments\": [{\"author\": \"szm007\", \"body\": \"[.] will match any character,try [\\\\\\\\.]\\r\\nYou should learn about escape characters\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_53", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"53\", \"title\": \"matchlen may be wrong\", \"author\": \"xavieryin\", \"labels\": [], \"description\": \"`int match_len;`\\r\\n`char* s = \\\"aa\\\";`\\r\\n`char* p = \\\".*a.*a\\\";`\\r\\n`int match_idx = re_match(p, s, &match_len);`\\r\\n\\r\\nexpected: match_len == 2\\r\\nresult:       match_len == 3\", \"comments\": [{\"author\": \"xavieryin\", \"body\": \"Is anyone also facing this problem?\\r\\nOr am I doing something incorrectly?\"}, {\"author\": \"kkos\", \"body\": \"Yes, I did. I had the same result as you.\\r\\nAnd in the next pattern and string, returns length=5.\\r\\n\\r\\npattern = \\\".*a.+a\\\"\\r\\nstring =  \\\"aaa\\\"\\r\\n\"}, {\"author\": \"xavieryin\", \"body\": \"Quick note: tried #63 , but no luck\"}, {\"author\": \"xavieryin\", \"body\": \"no luck by applying #61\"}, {\"author\": \"essele\", \"body\": \"Hi,\\r\\n\\r\\nI'm not sure if this is the same issue, but I'm matching \\\"\\\\n\\\\n+\\\" in a simple text file (looking for multiple-newline separated paragraphs, and I noticed that matchlen was actually counting every \\\\n that it came across rather than just the number of them actually matching the pattern.\\r\\n\\r\\nThe fix is simple ... in re_matchp() matchlen is not zero'd when you get a matchpattern() failure. I simply added a \\\"*matchlength = 0\\\" as the last line in the do/while loop and it seems to be working perfectly ... I will do some more testing.\\r\\n\\r\\nRegards,\\r\\n\\r\\nLee.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_56", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"56\", \"title\": \"Incorrect results for repeat operators\", \"author\": \"kkos\", \"labels\": [], \"description\": \"(1) Matching a? or a* with an empty string failed.\\r\\n(2) Using nested repeat operators failed.  For example, a?+ with string \\\"a\\\".\\r\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @kkos and thanks for the notice :+1: \\r\\n\\r\\nCould you please provide some code so I can be certain what cases we are talking about.\\r\\n\\r\\nCould you perhaps make a PR editing some of https://github.com/kokke/tiny-regex-c/blob/master/tests/test1.c to showcase exactly the cases you're talking about in 1) 2) ?\\r\\n\\r\\nThat would help me understand your issue :)\"}, {\"author\": \"kkos\", \"body\": \"I don't even know if it supports nested repeat operators in the first place, so I'll refrain from writing a PR.\\r\\nBut if you want to match the Python result, you would have something like this:\\r\\n\\r\\n```C\\r\\n  { OK,  \\\"a?\\\",                        \\\"\\\",                 (char*) 0      },\\r\\n  { OK,  \\\"a?\\\",                        \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a*\\\",                        \\\"\\\",                 (char*) 0      },\\r\\n  { OK,  \\\"a??\\\",                       \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a?*\\\",                       \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a?+\\\",                       \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a*?\\\",                       \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a**\\\",                       \\\"a\\\",                (char*) 1      },\\r\\n  { OK,  \\\"a*+\\\",                       \\\"a\\\",                (char*) 1      },\\r\\n  { OK,  \\\"a+?\\\",                       \\\"a\\\",                (char*) 0      },\\r\\n  { OK,  \\\"a+*\\\",                       \\\"a\\\",                (char*) 1      },\\r\\n  { OK,  \\\"a++\\\",                       \\\"a\\\",                (char*) 1      },\\r\\n```\\r\\n\\r\\nThe Python code I tested:\\r\\n\\r\\n```Python\\r\\n#!/usr/bin/env python3                                                          \\r\\n# -*- coding: utf-8 -*-                                                         \\r\\n\\r\\nimport re\\r\\n\\r\\n# (1)                                                                           \\r\\nprint(re.match(r'a??', \\\"\\\"))\\r\\n#=>  <re.Match object; span=(0, 0), match=''>                                   \\r\\n\\r\\nprint(re.match(r'a??', \\\"a\\\"))\\r\\n#=>  <re.Match object; span=(0, 0), match=''>                                   \\r\\n\\r\\nprint(re.match(r'a*', \\\"\\\"))\\r\\n#=>  <re.Match object; span=(0, 0), match=''>                                   \\r\\n\\r\\n# (2)                                                                           \\r\\nprint(re.match(r'(?:a??)??', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 0), match=''>                                    \\r\\n\\r\\nprint(re.match(r'(?:a??)*', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 0), match=''>                                    \\r\\n\\r\\nprint(re.match(r'(?:a??)+', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 0), match=''>                                    \\r\\n\\r\\nprint(re.match(r'(?:a*)??', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 0), match=''>                                    \\r\\n\\r\\nprint(re.match(r'(?:a*)*', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 1), match='a'>                                   \\r\\n\\r\\nprint(re.match(r'(?:a*)+', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 1), match='a'>                                   \\r\\n\\r\\nprint(re.match(r'(?:a+)??', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 0), match=''>                                    \\r\\n\\r\\nprint(re.match(r'(?:a+)*', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 1), match='a'>                                   \\r\\n\\r\\nprint(re.match(r'(?:a+)+', \\\"a\\\"))\\r\\n#=> <re.Match object; span=(0, 1), match='a'>                                   \\r\\n```\"}, {\"author\": \"kokke\", \"body\": \"Hi @kkos and thanks for helping me understand the issue 👍 \\r\\n\\r\\nI don’t think the nested operators are supported easily, but I will have a look and get back to you\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_57", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"57\", \"title\": \"I ported this to rust\", \"author\": \"gmorenz\", \"labels\": [], \"description\": \"Hi,\\r\\n\\r\\nJust thought I'd let you know that I ported this to rust for fun after seeing it on [lobste.rs](https://lobste.rs/s/xouda7/small_regex_implementation_c_less_than). The [repo is here](https://github.com/gmorenz/tiny-regex-rs). There are a few small changes in internals, but it's a reasonably direct port.\\r\\n\\r\\nThanks for making this cool little library :)\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @gmorenz and thanks for letting me know about your project :) I am not yet well versed in Rust, but I'll take a look.\\r\\n\\r\\nI am currently using the Python re module as test oracle, which is kinda slow. It would be nice to have something faster like an implementation in Rust (yours?) - maybe just as an addition to Python. Would that be an fun project?\\r\\n\\r\\nI noticed a ~20x increase in traffic on this project over the past two days and found a lot of it coming from reddit and lobste.rs :D\\r\\n\\r\\n> Thanks for making this cool little library :)\\r\\n\\r\\nHey thank you for using it, and thanks for posting the link to the lobste.rs post as well :D I'm curious to see how the code looks when Rustified :+1: \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_59", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"59\", \"title\": \"Add Precompiled Regex Code Generator\", \"author\": \"marler8997\", \"labels\": [], \"description\": \"I decided to use this library for a scripting language I'm working on.  Here's a link to the directory that uses it if you're interested: https://github.com/stitchlang/stitch/tree/fedf09a6a522e8e48c963075c84aa44cfc74a951/src\\r\\n\\r\\nOne thing I wanted was to \\\"compile\\\" my regular expressions at compile time rather than runtime.  Not only is this more performant, but it means I can have as many as I want (see https://github.com/kokke/tiny-regex-c/issues/3) and I don't need to allocate dynamic memory for them.\\r\\n\\r\\nTo solve this, I first noted that the `regex_t` data-structure is very simple:\\r\\n\\r\\n```c\\r\\ntypedef struct regex_t\\r\\n{\\r\\n  unsigned char  type;   /* CHAR, STAR, etc.                      */\\r\\n  union\\r\\n  {\\r\\n    unsigned char  ch;   /*      the character itself             */\\r\\n    unsigned char* ccl;  /*  OR  a pointer to characters in class */\\r\\n  } u;\\r\\n} regex_t;\\r\\n```\\r\\n\\r\\nI was able to write a function that takes a `regex_t` object and generates \\\"C initializtion\\\" code to \\\"recreate itself\\\". This function was easy to write becuase `re.c` already has a function named `re_print` that does something very similar.  Here's what it looks like:\\r\\n\\r\\n```c\\r\\n#include <re.h>\\r\\nstatic regex_t INLINE_WHITESPACE[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 8, { .ccl = (unsigned char*)\\\" \\\\t\\\" } }, // CHAR_CLASS\\r\\n    { .type = 6 }, // PLUS\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t USER_ID[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '$' } }, // CHAR\\r\\n    { .type = 8, { .ccl = (unsigned char*)\\\"a-zA-Z0-9_\\\\\\\\.\\\" } }, // CHAR_CLASS\\r\\n    { .type = 6 }, // PLUS\\r\\n    { .type = 7, { .ch = '$' } }, // CHAR\\r\\n    { .type = 4 }, // QUESTIONMARK\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t NEWLINE[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '\\\\n' } }, // CHAR\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t QUOTED_STRING[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '\\\"' } }, // CHAR\\r\\n    { .type = 9, { .ccl = (unsigned char*)\\\"\\\\\\\"\\\" } }, // INV_CHAR_CLASS\\r\\n    { .type = 5 }, // STAR\\r\\n    { .type = 7, { .ch = '\\\"' } }, // CHAR\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t COMMENT[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '#' } }, // CHAR\\r\\n    { .type = 9, { .ccl = (unsigned char*)\\\"\\\\n\\\" } }, // INV_CHAR_CLASS\\r\\n    { .type = 5 }, // STAR\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t OPEN_PAREN[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '(' } }, // CHAR\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t CLOSE_PAREN[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = ')' } }, // CHAR\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\nstatic regex_t ESCAPE_SEQUENCE[] = {\\r\\n    { .type = 2 }, // BEGIN\\r\\n    { .type = 7, { .ch = '@' } }, // CHAR\\r\\n    { .type = 8, { .ccl = (unsigned char*)\\\"@#$\\\\\\\")(\\\" } }, // CHAR_CLASS\\r\\n    { .type = 0 }, // UNUSED\\r\\n};\\r\\n```\\r\\n\\r\\nWith the C initialization code, I can compile my regex objects directly into my final binary.  Now I don't need to call `re_compile` at runtime.  I can have as many regular expressions as I want and there's no need for dynamic memory.\\r\\n\\r\\nNote that one big piece to this puzzle was exposing the `regex_t` definition to the user by moving it to the public header file `re.h`.  Without this, the user would not be able to initalize the objects at compile-time.\\r\\n\\r\\nFor reference here's the function I wrote to generate this initialization code (https://github.com/stitchlang/stitch/blob/fedf09a6a522e8e48c963075c84aa44cfc74a951/src/tokens/compiler.c#L21).  As you can see it's quite trivial.  If a similar function were added to the library, even in a separate file like `cgenerator.c` then others would easily be able to do this as well.\\r\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @marler8997 and thanks for all your effort (seeing all your other PRs etc.) :+1: \\r\\n\\r\\nThanks for the kind words. I also think the code is legible enough to be hackable, which is usually a quasi design goal.\\r\\n\\r\\nSorry for not having responded until now. I am super busy at work and privately at the moment and do not have time/energy to read or review all your nice suggestions. I expect it to clear up near months end, but please bear with me until then.\\r\\n\\r\\nPlease do not take it for neglect or disregard. I **really** appreciate your efforts.\"}, {\"author\": \"kokke\", \"body\": \"Having (quickly!) read the README, I like the idea of stitch. I'm checking the examples now.\"}, {\"author\": \"marler8997\", \"body\": \"> Sorry for not having responded until now. I am super busy at work and privately at the moment and do not have time/energy to read or review all your nice suggestions. I expect it to clear up near months end, but please bear with me until then.\\r\\n\\r\\nOk no problem thanks for letting me know.  I have everything I need for right now with my fork and/or branch but if/when you're ready I'm willing to put in effort into upstreaming any changes, bug fixes or features you'd like to bring in as well.  I'll plan on doing that after you find some time to address my current PRs.  My hope is my fork/branch are only temporary until we can negotiate which changes can and should be upstreamed here.\"}, {\"author\": \"marler8997\", \"body\": \"> Having (quickly!) read the README, I like the idea of stitch. I'm checking the examples now.\\r\\n\\r\\nThanks!  This is probably my 5th attempt to come up with something to replace my BASH scripts that I'm happy with.  I think I have most of the overall language roughly laid out, but there's still alot of smaller details to figure out such as if I should add keywords, if I should represent binary operators in the syntax or not, if I should add special syntax for arrays and/or environment variables.  But luckily the way I have it now is I can easily make changes and experiment without having to write anything in stone.  Hopefully it will be ready for production in the coming months.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_66", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"66\", \"title\": \"Python random tests are failing but CI is passing\", \"author\": \"marler8997\", \"labels\": [], \"description\": \"The `regex_test.py` and `regex_test_neg.py` scripts are failing but they don't return a non-zero exit code.  This causes the Makefile to continue on like nothing went wrong thinking that everything passed.  This can be fixed by adding the following lines to the end of the regex python scripts:\\r\\n\\r\\n```python\\r\\nif nfails != 0:\\r\\n    sys.exit(1)\\r\\n```\\r\\n\\r\\nThe problem is that this will cause the CI to fail because the tests currently aren't passing, see alll the \\\"FAIL\\\" tests in this run: https://github.com/kokke/tiny-regex-c/runs/1939275804?check_suite_focus=true\\r\\n\\r\\n```\\r\\n[..snip..]\\r\\npattern '[1-5-]+[-1-2]-[-]':         FAIL : doesn't match '-5--34522125-3131---' as expected [0x2d, 0x35, 0x2d, 0x2d, 0x33, 0x34, 0x35, 0x32, 0x32, 0x31, 0x32, 0x35, 0x2d, 0x33, 0x31, 0x33, 0x31, 0x2d, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '31433--3-33325121--' as expected [0x33, 0x31, 0x34, 0x33, 0x33, 0x2d, 0x2d, 0x33, 0x2d, 0x33, 0x33, 0x33, 0x32, 0x35, 0x31, 0x32, 0x31, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '12-32342324113--12--' as expected [0x31, 0x32, 0x2d, 0x33, 0x32, 0x33, 0x34, 0x32, 0x33, 0x32, 0x34, 0x31, 0x31, 0x33, 0x2d, 0x2d, 0x31, 0x32, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '455354554121-4515---' as expected [0x34, 0x35, 0x35, 0x33, 0x35, 0x34, 0x35, 0x35, 0x34, 0x31, 0x32, 0x31, 0x2d, 0x34, 0x35, 0x31, 0x35, 0x2d, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '---5551121353354--2--' as expected [0x2d, 0x2d, 0x2d, 0x35, 0x35, 0x35, 0x31, 0x31, 0x32, 0x31, 0x33, 0x35, 0x33, 0x33, 0x35, 0x34, 0x2d, 0x2d, 0x32, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '215535-35551-442--' as expected [0x32, 0x31, 0x35, 0x35, 0x33, 0x35, 0x2d, 0x33, 0x35, 0x35, 0x35, 0x31, 0x2d, 0x34, 0x34, 0x32, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '5-342342452523-52-41--' as expected [0x35, 0x2d, 0x33, 0x34, 0x32, 0x33, 0x34, 0x32, 0x34, 0x35, 0x32, 0x35, 0x32, 0x33, 0x2d, 0x35, 0x32, 0x2d, 0x34, 0x31, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '55515455412-1--' as expected [0x35, 0x35, 0x35, 0x31, 0x35, 0x34, 0x35, 0x35, 0x34, 0x31, 0x32, 0x2d, 0x31, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '2-3---' as expected [0x32, 0x2d, 0x33, 0x2d, 0x2d, 0x2d].\\r\\n    FAIL : doesn't match '444-2-3412--45433-1--' as expected [0x34, 0x34, 0x34, 0x2d, 0x32, 0x2d, 0x33, 0x34, 0x31, 0x32, 0x2d, 0x2d, 0x34, 0x35, 0x34, 0x33, 0x33, 0x2d, 0x31, 0x2d, 0x2d].\\r\\n[..snip..]\\r\\n```\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_67", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"67\", \"title\": \"regex compilation is making things slower?\", \"author\": \"marler8997\", \"labels\": [], \"description\": \"After my experiment to change to a \\\"flat memory layout\\\" here (https://github.com/kokke/tiny-regex-c/pull/62), I had a suspicion that the regex compilation may not be improving performance by much.  It took a while but I re-implemented everything without compilation in this commit https://github.com/marler8997/tiny-regex-c/commit/8311dc883418407e83fcdf2468867e3f3448ca93.  Turns out that without regex compilation, the implementation is around 300 SLOC (instead of 500) and about 15% faster on my machine.\\r\\n\\r\\nBut hold on, it probably wasn't a fair race.  My commit also has some other changes that help out performance (like https://github.com/kokke/tiny-regex-c/pull/63).  If all things were equal, the compiled version still might be faster in some cases, I'm not actually sure.  It does seem clear that both the compiled and non-compiled versions perform very similarly, but I think each one will be better in certain environments , on certain machines or with different workloads.\\r\\n\\r\\nThat being said, I feel like the change aligns well with the goals of this project, the primary one in the name \\\"tiny-regex-c\\\" which is now even \\\"tiny-er\\\".  The other nice benefit is not needing to allocate anything for the regex objects nor needing static memory for them. (makes https://github.com/kokke/tiny-regex-c/issues/3 a non issue).\\r\\n\\r\\nI also noticed that while removing compilation, I also happened to fix a few bugs (see some of them below).  I also added makefile targets for each test along with a comprehensive test that runs all the targets from a clean repo (because if you don't write a test for it, then it will break).\\r\\n\\r\\nI'm unsure whether @kokke will want to take this commit as it's such a huge fundamental change, but I figure I'd let you know the implementation is here, feel free to take all or none of the idea into this repository.  I'm also happy to submit PR's for individual changes from this idea as I'm sure you'll not want to take everything all at once (I know I wouldn't).  However, right now I've got 7 PRs in the queue so I'll hold off on making any more until some of those ones are settled.\\r\\n\\r\\nSummary of related issues\\r\\n\\r\\nfixes https://github.com/kokke/tiny-regex-c/issues/3\\r\\nfixes https://github.com/kokke/tiny-regex-c/issues/40\\r\\nfixes part (1) of https://github.com/kokke/tiny-regex-c/issues/53\\r\\ninvalidates https://github.com/kokke/tiny-regex-c/issues/59\\r\\nfixes https://github.com/kokke/tiny-regex-c/issues/66\\r\\nfixes https://github.com/kokke/tiny-regex-c/issues/69\\r\\n\", \"comments\": [{\"author\": \"rurban\", \"body\": \"When I wrote such a simple matcher back in the 90ties, I skipped the compilation part, as it is slower and needs memory. Just dynamic matching was enough. \\r\\nI had even group expressions then, and the matchers where much simpler, similar to Rob Pike's. I wrote it for asterisk, but cannot find it anymore.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_68", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"68\", \"title\": \"support for non-greedy `*?` and `+?`\", \"author\": \"marler8997\", \"labels\": [], \"description\": \"tiny-regex-c can add support for these simply by reversing the order of the 2 code blocks in `matchplus` and `matchstar`\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_69", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"69\", \"title\": \"Wrong match length?\", \"author\": \"yoyopoleg\", \"labels\": [], \"description\": \"Hi,\\r\\nI ran into an issue in the following scenario:\\r\\n`pattern = re_compile(\\\"{\\\\\\\\w+}\\\");`\\r\\n`match_pos = re_matchp(pattern, \\\"{{FW}_TEST\\\", &match_length);`\\r\\n\\r\\nThe result is that match_pos==1 (correct), but match_length==5 (incorrect).\\r\\nI was expecting to get match_pos==0 and match_length==5 --OR-- match_pos=1 and match_length==4.\\r\\nTnx\\r\\nYair\", \"comments\": [{\"author\": \"xavieryin\", \"body\": \"Looks comparable to #53.\\r\\nPlease also refer to #67, which may help on your case.\\r\\n\"}, {\"author\": \"yoyopoleg\", \"body\": \"I tried the code from here: https://github.com/marler8997/tiny-regex-c, no luck :/\\r\\n\"}, {\"author\": \"marler8997\", \"body\": \"@yoyopoleg sorry I didn't get notified about your comment 26 days ago, but I just happened to be looking through these issues today.  All my changes are on the `nocompile` branch in my repo, maybe you were using the `master` branch?  I've added your test case here:\\r\\n\\r\\nhttps://github.com/marler8997/tiny-regex-c/pull/1/files#diff-17bb50ff94ad23665e8837f348d16688af778a443dda0e15dcb073ce32ead4f8R225\\r\\n\\r\\non my branch I get a match position of `1` and a match length of `4` which I believe is what you would expect.\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_70", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"70\", \"title\": \"Error on isdigit, isalpha, isspace with char > 127\", \"author\": \"ghost\", \"labels\": [], \"description\": \"The is*** functions to check if a char is a digit or space fail if you pass a char that's above 127.\\r\\n\\r\\nhttps://en.cppreference.com/w/cpp/string/byte/isalpha\\r\\n\\r\\nDepending on your compiler you might get an error. You can fix this by casting the value to `unsigned char`.\\r\\nTry and match this \\\"Çüéâ\\\" as ASCII.\\r\\n\\r\\n```c++\\r\\nstatic int matchdigit(char c)\\r\\n{\\r\\n  return isdigit((unsigned char)c);\\r\\n}\\r\\nstatic int matchalpha(char c)\\r\\n{\\r\\n  return isalpha((unsigned char)c);\\r\\n}\\r\\nstatic int matchwhitespace(char c)\\r\\n{\\r\\n  return isspace((unsigned char)c);\\r\\n}\\r\\n```\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_71", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"71\", \"title\": \"re_matchp succeeds only for the first string compared to a pattern\", \"author\": \"MiloDC\", \"labels\": [], \"description\": \"`re_t myRe = re_compile(\\\"^[^=]+=[^=]+$\\\");`\\r\\n`int matchLen;`\\r\\n`re_matchp(myRe, \\\"operationName=PublishEditMessageClients\\\", &matchLen);` (= > -1)\\r\\n`re_matchp(myRe, \\\"operationName=DeleteMessageClients\\\", &matchLen);` (= < 0)\\r\\n`re_matchp(myRe, \\\"operationName=PublishEditMessageClients\\\", &matchLen);` (= > -1)\\r\\n`re_matchp(myRe, \\\"operationName=PublishDirectMessageClients\\\", &matchLen);` (= < 0)\\r\\n\\r\\nAs you can see, only the first string matched against the pattern yields a successful match.  Any other string thereafter yields failure.  Why is this?\", \"comments\": [{\"author\": \"Amiralgaby\", \"body\": \"in re.c\\r\\nthere is this written\\r\\n```c\\r\\n/*\\r\\n *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}\\r\\n *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!\\r\\n*/\\r\\n```\\r\\nI see you use inverted class, but i don't realized test if you are right\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_73", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"73\", \"title\": \"vcpkg installion windows -  length is not changing in return \", \"author\": \"hInfern0\", \"labels\": [], \"description\": \"![image](https://user-images.githubusercontent.com/69460530/125150764-a0fda280-e142-11eb-86a5-89a7710a368f.png)\\r\\n\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_74", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"74\", \"title\": \"support for {n,m},repeat N to M times?\", \"author\": \"TMODER\", \"labels\": [], \"description\": \"\", \"comments\": [{\"author\": \"rurban\", \"body\": \"Done in my rurban/times branch. https://github.com/rurban/tiny-regex-c/tree/times\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_76", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"76\", \"title\": \"Software vulnerabilities detected during code analysis with ESBMC-WR tool\", \"author\": \"janislley\", \"labels\": [], \"description\": \"Hello,\\r\\n\\r\\nOne potential software vulnerability was found in code.\\r\\nTo identify this kind of vulnerabilities I used ESBMC-WR tool: https://github.com/thalestas/esbmc-wr\\r\\nWe detect it during code exploitation for RUFUS tool.\\r\\nA bug was reported at this time and the developer of RUFUS tool requested to solve this potential issue directly here in mainline code.\\r\\n\\r\\nBug reported at RUFUS repository code: https://github.com/pbatard/rufus/issues/1856\\r\\n\\r\\nMore about the tool: https://arxiv.org/pdf/2102.02368.pdf\\r\\n\\r\\nExpected behavior:\\r\\n\\r\\nOur main objective was to check memory safety\\r\\nproperties (e.g., pointer dereference and memory leaks) while\\r\\nperforming the verification code.\\r\\n\\r\\nPlease, check the logs of analysis:\\r\\n\\r\\n**Issue**\\r\\n[FILE] src/re.c\\r\\n\\r\\nState 5 file re.c line 269 function re_print thread 0\\r\\nViolated property:\\r\\nfile re.c line 269 function re_print\\r\\narray bounds violated: array `types' upper bound\\r\\n(signed long int)(pattern + (signed long int)i)->type < 17\", \"comments\": [{\"author\": \"janislley\", \"body\": \"This issue was fixed and fix provided. \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_79", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"79\", \"title\": \"fix pattern '[1-5-]+' against '123-'\", \"author\": \"rurban\", \"labels\": [], \"description\": \"A final - in a character class should not be stopped by the interim range char -.\\r\\n\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_81", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"81\", \"title\": \"Do not support {n, m} feature.\", \"author\": \"cmtheit\", \"labels\": [], \"description\": \"Regex is [a-z][a-z0-9]{0, 10},\\r\\nMatch string is \\\"cmtheit\\\",\\r\\nDo not match. \", \"comments\": [{\"author\": \"mickjc750\", \"body\": \"Testing this on https://regex101.com/\\r\\nYour Regex appears to be broken by the space after the ,\\r\\nInstead of:\\r\\n[a-z][a-z0-9]{0, 10}\\r\\ntry:\\r\\n[a-z][a-z0-9]{0,10}\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_83", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"83\", \"title\": \"Not only does [^blah] not work but the non-inverted [blah] doesn't work either\", \"author\": \"infradig\", \"labels\": [], \"description\": \"Not only does [^blah] not work but the non-inverted [blah] doesn't work either.\\r\\n\\r\\n\", \"comments\": [{\"author\": \"infradig\", \"body\": \"Deleting this.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_84", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"84\", \"title\": \"Cannot match end-of-pattern match\", \"author\": \"perazz\", \"labels\": [], \"description\": \"Hi and thanks for an amazing library - I'm developing a Fortran port of it [here](https://github.com/perazz/fortran-regex). \\r\\n\\r\\nI've just found an issue/potential bug with the end-pattern command.\\r\\n\\r\\ntext = \\\"table football\\\"\\r\\npattern = \\\"l$\\\"\\r\\n\\r\\nreturns index=13, matchlength=3\\r\\n\\r\\nHere's the sample test program: \\r\\n\\r\\n```c\\r\\n#include <stdio.h>\\r\\n#include <stdlib.h>\\r\\n#include \\\"re.h\\\"\\r\\nint main() {\\r\\n\\r\\n   const char *text = \\\"table football\\\";\\r\\n   const char *pattern = \\\"l$\\\";\\r\\n   int index,len;\\r\\n\\r\\n   index = re_match(pattern, text, &len);\\r\\n\\r\\n   printf(\\\"index=%d len=%d \\\\n\\\",index,len);\\r\\n}\\r\\n```\\r\\n\\r\\nTested on Mac with clang 13.1.6\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_87", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"87\", \"title\": \"re.\", \"author\": \"Bond1313\", \"labels\": [], \"description\": \"\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @Bond1313 \\r\\n\\r\\nThis issue is empty - did you create it by mistake? 😅 I will close it for now. \\r\\n\\r\\nIf you instead have a question or want to discuss something, please just let me know.\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_88", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"88\", \"title\": \"Match of `\\\\\\\\s*` on empty string reports `pos == -1`, i.e., no match, while it should report `pos == 0` and `matchlength == 0`\", \"author\": \"grigory-rechistov-intel\", \"labels\": [], \"description\": \"Consider this program, which tries to match zero or more space characters in a string of length zero:\\r\\n\\r\\n```\\r\\n// $ cat empty-str.c\\r\\n#include \\\"re.h\\\"\\r\\n#include \\\"assert.h\\\"\\r\\n\\r\\nint main() {\\r\\n    int matchlength = 0;\\r\\n    int pos = re_match(\\\"\\\\\\\\s*\\\", \\\"\\\", &matchlength);\\r\\n    assert(pos != -1);\\r\\n    return 0;\\r\\n}\\r\\n```\\r\\n\\r\\nWhen compiled with re.c and executed, the assertion fails:\\r\\n```\\r\\n$ gcc empty-str.c re.c\\r\\n$ ./a.out\\r\\na.out: empty-str.c:7: main: Assertion `pos != -1' failed.\\r\\nAborted (core dumped)\\r\\n```\\r\\n\\r\\nIt is an interesting question about what the result of a successful match for an empty string should be. My take on it is that it should not report a failure for matching (i.e. the return value must not be negative), but the length of the match should be zero.\\r\\n\", \"comments\": []}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_89", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"89\", \"title\": \"Migrate all test scripts to Python v3\", \"author\": \"rilysh\", \"labels\": [], \"description\": \"Hello,\\n\\nCurrently, test scripts uses syntax and libraries from Python 2 but most GNU/Linux\\ndistributions has remove Python 2 from their repository, making it harder\\nto get a Py2 binary unless compiling it from source. It'd be nice if you or\\nan individual migrate them to use Python 3. I'm more than happy to help if needed!\\n\\nThanks!\\n\\n\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Hi @rilysh\\r\\n\\r\\nI agree that would be nice. I don't have much time for FOSS contributions at the moment, but if you are willing to make some efforts I would be happy to accept the help.\\r\\n\\r\\nIf you're willing to undertake the migration effort, I suggest doing it somewhat like this:\\r\\n\\r\\n- Open a branch (e.g. called ´python3-support` or similar) and make the work there\\r\\n  That makes it easy to compare against the `main`-branch.\\r\\n- You can make all work on a single branch or make branches for each major change (not sure that makes a lot of sense here)\\r\\n- When you think you're finished, open a PR and let me review the changes.\\r\\n  I assume the changes will be mostly mechanical and minor, as it's just a change from v2 -> v3 and not a rewrite of the functionality.\\r\\n- I would also be willing to discuss the proposed changes in one or more issues before you implement them. Your choice.\\r\\n\\r\\nApologies beforehand if I'm a bit slow to react. I have many irons in the fire 🔥🐝\"}, {\"author\": \"kokke\", \"body\": \"Finally found time to do this :sweat_smile: \"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_92", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"92\", \"title\": \"Does not support OR regex (|)-operator\", \"author\": \"Raffa2005\", \"labels\": [], \"description\": \"\", \"comments\": [{\"author\": \"kokke\", \"body\": \"Correct, capture groups and alternation is not supported.\\r\\n\\r\\nOther issues about the same topic\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/issues/11\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/issues/28\\r\\n\\r\\nhttps://github.com/kokke/tiny-regex-c/issues/38\\r\\n\\r\\n\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_93", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"93\", \"title\": \"RegEx gets no match\", \"author\": \"wills721\", \"labels\": [], \"description\": \"Using this pattern:\\r\\n    char * pattern = \\\"/([^=,]*)=(\\\\\\\"[^\\\\\\\"]*\\\\\\\"|[^,\\\\\\\"]*)/\\\";\\r\\n\\r\\nre-compile passes but I do not get a match on this data:\\r\\n    char * data = \\\"aa=88,bb=99,cc=77\\\";\\r\\n\\r\\nAny help would be appreciated :) \", \"comments\": [{\"author\": \"philip-h-dye\", \"body\": \"Did you lose a character when copying it?\\r\\n\\r\\n[ 5 ] phdyex @ xps-ne ~/play/tiny-regex-c/tests\\r\\n$ gcc -I.. -c test7.c\\r\\ntest7.c:21:31: error: expected expression before ‘^’ token\\r\\n   21 | char * pattern = \\\"/([^=,])=(\\\"[^\\\\\\\"]\\\"|[^,\\\\\\\"]*)/\\\";\\r\\n      |                               ^\\r\\n\\r\\nOn Wed, Dec 18, 2024 at 8:09 AM wills721 ***@***.***> wrote:\\r\\n\\r\\n> Using this pattern:\\r\\n> char * pattern = \\\"/([^=,]*)=(\\\"[^\\\\\\\"]*\\\"|[^,\\\\\\\"]*)/\\\";\\r\\n>\\r\\n> I do not get a match on this data:\\r\\n> char * data = \\\"aa=88,bb=99,cc=77\\\";\\r\\n>\\r\\n> Any help would be appreciated :)\\r\\n>\\r\\n> —\\r\\n> Reply to this email directly, view it on GitHub\\r\\n> <https://github.com/kokke/tiny-regex-c/issues/93>, or unsubscribe\\r\\n> <https://github.com/notifications/unsubscribe-auth/AIQYKD2TPWX5NIITEPPRTST2GFXZ3AVCNFSM6AAAAABT2VPREGVHI2DSMVQWIX3LMV43ASLTON2WKOZSG42DONZXGU4DIOI>\\r\\n> .\\r\\n> You are receiving this because you are subscribed to this thread.Message\\r\\n> ID: ***@***.***>\\r\\n>\\r\\n\"}, {\"author\": \"philip-h-dye\", \"body\": \"char* test_vector[][4] =\\r\\n{\\r\\n    { OK,  \\\"/([^=,])=(\\\\\\\"[^\\\\\\\"]\\\\\\\"|[^,\\\\\\\"]*)/\\\",  \\\"aa=88,bb=99,cc=77\\\", (char*) 0\\r\\n},\\r\\n};\\r\\n\\r\\n$ ./tests/test7\\r\\n\\r\\ntype: CHAR '/'\\r\\ntype: CHAR '('\\r\\ntype: INV_CHAR_CLASS [=,]\\r\\ntype: CHAR ')'\\r\\ntype: CHAR '='\\r\\ntype: CHAR '('\\r\\ntype: CHAR '\\\"'\\r\\ntype: INV_CHAR_CLASS [\\\"]\\r\\ntype: CHAR '\\\"'\\r\\ntype: CHAR '|'\\r\\ntype: INV_CHAR_CLASS [,\\\"]\\r\\ntype: STAR\\r\\ntype: CHAR ')'\\r\\ntype: CHAR '/'\\r\\n[1/1]: pattern '/([^=,])=(\\\"[^\\\"]\\\"|[^,\\\"]*)/' didn't match 'aa=88,bb=99,cc=77'\\r\\nas expected.\\r\\n0/1 tests succeeded.\\r\\n\\r\\n\\r\\n\\r\\nOn Wed, Dec 18, 2024 at 12:28 PM Philip Dye ***@***.***> wrote:\\r\\n\\r\\n> Did you lose a character when copying it?\\r\\n>\\r\\n> [ 5 ] phdyex @ xps-ne ~/play/tiny-regex-c/tests\\r\\n> $ gcc -I.. -c test7.c\\r\\n> test7.c:21:31: error: expected expression before ‘^’ token\\r\\n>    21 | char * pattern = \\\"/([^=,])=(\\\"[^\\\\\\\"]\\\"|[^,\\\\\\\"]*)/\\\";\\r\\n>       |                               ^\\r\\n>\\r\\n> On Wed, Dec 18, 2024 at 8:09 AM wills721 ***@***.***> wrote:\\r\\n>\\r\\n>> Using this pattern:\\r\\n>> char * pattern = \\\"/([^=,]*)=(\\\"[^\\\\\\\"]*\\\"|[^,\\\\\\\"]*)/\\\";\\r\\n>>\\r\\n>> I do not get a match on this data:\\r\\n>> char * data = \\\"aa=88,bb=99,cc=77\\\";\\r\\n>>\\r\\n>> Any help would be appreciated :)\\r\\n>>\\r\\n>> —\\r\\n>> Reply to this email directly, view it on GitHub\\r\\n>> <https://github.com/kokke/tiny-regex-c/issues/93>, or unsubscribe\\r\\n>> <https://github.com/notifications/unsubscribe-auth/AIQYKD2TPWX5NIITEPPRTST2GFXZ3AVCNFSM6AAAAABT2VPREGVHI2DSMVQWIX3LMV43ASLTON2WKOZSG42DONZXGU4DIOI>\\r\\n>> .\\r\\n>> You are receiving this because you are subscribed to this thread.Message\\r\\n>> ID: ***@***.***>\\r\\n>>\\r\\n>\\r\\n\"}, {\"author\": \"wills721\", \"body\": \"I had the escape chars wrong.....but you show the compilation working (I got that to succeed).....not the matching? Should re_matchp  not have picked out aa and 88 and bb and 99 ... ?\"}]}"}]}}
{"custom_id": "kokke_tiny-regex-c_issue_94", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-5-mini", "temperature": 1, "response_format": {"type": "json_schema", "json_schema": {"name": "RegexIssueClassification", "schema": {"type": "object", "properties": {"number": {"type": "string"}, "is_real_bug": {"type": "boolean"}, "is_fixed": {"type": "boolean"}, "found_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "fixed_pointer": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": ["string", "null"], "enum": ["Version", "Commit Hash", "Pull Request Number", "Other", null]}, "value": {"type": ["string", "null"]}}, "required": ["type", "value"], "additionalProperties": false}}, "bug_kind": {"type": ["string", "null"], "enum": ["SEMANTIC", "CRASH", "DIFF", "PERF", "MEMORY", "DOC", "OTHER", null]}, "how_found": {"type": ["string", "null"], "enum": ["FUZZING", "STATIC_ANALYSIS", "MANUAL_REVIEW", "DIFFERENTIAL_TESTING", "OTHER", null]}, "reproduction_pattern_and_input": {"type": "array", "items": {"type": "object", "properties": {"pattern": {"type": ["string", "null"]}, "input": {"type": ["string", "null"]}}, "required": ["pattern", "input"], "additionalProperties": false}}, "log": {"type": ["string", "null"]}, "summary": {"type": "string"}}, "required": ["number", "is_real_bug", "is_fixed", "found_pointer", "fixed_pointer", "bug_kind", "how_found", "reproduction_pattern_and_input", "log", "summary"], "additionalProperties": false}, "strict": true}}, "messages": [{"role": "system", "content": "You are a **software engineering and cybersecurity researcher** specializing in **regular expression (regex) engine analysis**.\nYour research project aims to **systematically evaluate and categorize bugs** in regex engines by mining and interpreting historical issue reports.\n\nYou are currently analyzing the **tiny-regex-c** regex engine, developed by **kokke**.\n\nFor each task, you will be given **one issue report** in the following JSON format:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"title\": \"Issue Title\",\n    \"author\": \"johndoe\",\n    \"labels\": [\"bug\", \"feature\"],\n    \"description\": \"Issue Description\",\n    \"comments\": [\n        {\n            \"author\": \"johndoe\",\n            \"body\": \"Comment Body\"\n        }\n    ]\n}\n```\n\n---\n\n# **Your Goal**\n\nYour task is to decide whether the issue describes a **real bug** related to the tiny-regex-c regex engine and to **extract structured information** about the bug.\nYou must rely **only on the content explicitly stated or strongly implied** in the issue description and comments.\n\nIf the issue is **not** about an actual bug (e.g., question, misunderstanding, expected behavior, usage error, unsupported feature), then you must produce the **null-filled output** described later.\n\n---\n\n# **What Counts as a “Real Bug”**\n\n\nA real bug includes **any confirmed or strongly evidenced defect**, including:\n\n* **Semantic bugs**: incorrect match results, wrong interpretation of patterns.\n* **Crashes**: segmentation faults, aborts, panics.\n* **Performance bugs**: timeouts, catastrophic backtracking, unexpected slowdowns.\n* **Memory bugs**: leaks, buffer issues, tool-reported memory errors (ASan, UBSan, etc.).\n* **Differential bugs**: behavior differs between versions or across engines.\n* **Documentation bugs**: incorrect, misleading, incomplete, or inconsistent documentation associated with regex behavior or API usage.\n\nDo **not** classify as a bug:\n\n* misuse of the API\n* misunderstandings of regex semantics\n* invalid input or unsupported features\n* documentation or enhancement requests\n* behavioral questions with no confirmed fault\n\nWhen the existence of a bug is unclear, respond with **all null values**.\n\n---\n\n# **Output Format**\n\nYour output must be a valid JSON object with the following structure:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": true | false,\n    \"is_fixed\": true | false,\n    \"found_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"fixed_pointer\": [\n        {\n            \"type\": \"Version\" | \"Commit Hash\" | \"Pull Request Number\" | \"Other\" | null,\n            \"value\": \"Value\" | null\n        }\n    ],\n    \"bug_kind\": \"SEMANTIC\" | \"CRASH\" | \"DIFF\" | \"PERF\" | \"MEMORY\" | \"DOC\" | \"OTHER\" | null,\n    \"how_found\": \"FUZZING\" | \"STATIC_ANALYSIS\" | \"MANUAL_REVIEW\" | \"DIFFERENTIAL_TESTING\" | \"OTHER\" | null,\n    \"reproduction_pattern_and_input\": [\n        {\n            \"pattern\": \"Pattern\" | null,\n            \"input\": \"Input\" | null\n        }\n    ],\n    \"log\": \"Log\" | null,\n    \"summary\": \"Short summary of what the issue is about and the LLM's reasoning for the classification.\"\n}\n```\n\n### **Field Definitions**\n\n#### **is_real_bug**\n\n* Whether the issue is a real bug.\n* Set to `true` if the issue is a real bug, `false` otherwise.\n\n#### **is_fixed**\n\n* Whether the bug was fixed.\n* Set to `true` if the bug was fixed, `false` otherwise.\n\n#### **number**\n\n* The issue number.\n* You already know this from the issue report input, but you need to output it as well.\n\n#### **found_pointer**\n\n* The version, commit hash, or pull request number where the bug was observed.\n* The primary aim here is to pinpoint the locations so that we can rollback and reproduce the bug.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was found is explicitly stated.\n\n#### **fixed_pointer**\n\n* The version, commit hash, or pull request number where the bug was fixed.\n* If multiple of those are mentioned, you can add them all to the array.\n* Must come directly from the issue text or comments.\n* Return `[]` if not any kind of pointer to at which point the bug was fixed is explicitly stated.\n\n#### **bug_kind**\n\nChoose exactly one:\n\n| Value        | Meaning                                                                   |\n| ------------ | ------------------------------------------------------------------------- |\n| **SEMANTIC** | Incorrect matching, parsing, or interpretation of patterns                |\n| **CRASH**    | Crashes, panics, segmentation faults, unrecoverable errors                |\n| **DIFF**     | Behavioral differences (across versions or engines)                       |\n| **BUILD**    | Build issues or compilation errors when building the engine               |\n| **PERF**     | Performance issues, backtracking blowups, unexplained slowness            |\n| **MEMORY**   | Memory errors, leaks, invalid access, sanitizer outputs                   |\n| **DOC**      | **Documentation issues: misleading, incomplete, incorrect documentation** |\n| **OTHER**    | A genuine bug that does not fit any other category                        |\n\n\nFor `DIFF` bugs, behavioral differences can be observed in the two different versions of the same engine (e.g., new version vs. old version)\nand between different engines (e.g., tiny-regex-c vs. other engines). The behavioral difference can be in the acceptance of a pattern, \nthe span of the match, the captures, the number of matches, flag behavior, etc.\n\n#### **how_found**\n\nIdentify how the bug was discovered, if stated or there is enough evidence (e.g., usage of ASan for fuzzing):\n\n* FUZZING – found via fuzzing tools\n* STATIC_ANALYSIS – found via automated static analysis\n* MANUAL_REVIEW – found manually (e.g., user investigation)\n* DIFFERENTIAL_TESTING – found by comparing results with other engines\n* OTHER – explicitly stated custom method\n* `null` – if no discovery method is stated or implied\n\n#### **reproduction_pattern_and_input**\n\n* Extract all reproducible test cases provided.\n* Store each `(pattern, input)` pair separately (there can be multiple pairs).\n* Use `null` values only when the pattern or input is missing.\n* Sometimes, the provided pattern or input string is too long to be fit in the output format (e.g., excessive repeats of the same character or pattern).\n  * For example, the issue author might state a regex pattern or input similar to \"()()()...()\" (10000 times \"()\"). \n  * In this case, you can output a shorter representation like \"()()...()\" (50 times \"()\"). Mention that truncation in your summary.\n\n#### **log**\n\n* Include any crash logs, sanitizer output, stack traces, or diagnostic logs.\n* Store **exactly** what is provided, do not invent or summarize.\n* Use `null` if not present.\n\n#### **summary**\n\nA **2–6 sentence** explanation summarizing:\n\n* What the issue reports.\n* Whether and why it qualifies (or does not qualify) as a real bug.\n* Your reasoning for the chosen bug category and extracted fields.\n\nThis is the **only place where your reasoning may appear**.\nAll other fields should contain **no justification—only extracted data**.\n\n---\n\n# **If the Issue Is NOT a Real Bug**\n\nOutput the structure with all fields set to null or empty as below:\n\n```json\n{\n    \"number\": \"1234567890\",\n    \"is_real_bug\": false,\n    \"is_fixed\": false,\n    \"found_pointer\": [],\n    \"fixed_pointer\": [],\n    \"bug_kind\": null,\n    \"how_found\": null,\n    \"reproduction_pattern_and_input\": [],\n    \"log\": null,\n    \"summary\": \"Explanation of why this issue does not represent a real bug.\"\n}\n```\n\nThe number and summary must still be present; all other fields must be null or empty.\n\n---\n\n# **General Constraints**\n\n1. **Do not guess.** Only extract what is explicitly stated or can be strongly inferred from the issue description and comments.\n2. **Do not modify or correct the issue's content.** Extract it faithfully.\n3. **Only JSON output, no extra text.**\n4. **Ensure JSON is valid, syntactically correct, and uses only the allowed values.**\n5. **Never fabricate version numbers, logs, or test cases.**\n6. **Be consistent and precise.**\n"}, {"role": "user", "content": "{\"number\": \"94\", \"title\": \"This is not quite a regular expression engine\", \"author\": \"Bricktech2000\", \"labels\": [], \"description\": \"This is not quite a regular expression engine because the features currently supported are not sufficient to recognize the regular languages. For example, $\\\\\\\\{a^{2n} \\\\mid n \\\\in \\\\mathbb N\\\\\\\\}$ (as a regular expression, `(aa)*`) is regular but this engine’s features cannot describe it.\", \"comments\": []}"}]}}
